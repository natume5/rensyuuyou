#!/usr/bin/python
# -*- coding: UTF-8 -*-


print("--- Python学習講座---")
print("--- Python入門　例外処理---")


"""
例外と例外処理

プログラム実行には様々な前提があります。
例えば、割り算を計算する場合、分母は0以外でなければなりません。
ところが、こういった前提が満たされない例外的な事態が発生した場合、エラーとなりプログラムが中断されます。
こういった状態的な事態を「例外が発生した」と故障します。

前述のとおり例外が発生した場合はプログラムが中断されますが、
プログラムの規模が大きくなると即時プログラムを中断すると様々な問題が発生します。
軽微なものであったらプログラムを続行させたり、プログラムの中断までに原因をログ出力したり、
安全に終了するための措置をとる必要があります。
この発生した例外に対して何らかの処理をすることを例外処理と呼びます。
また、この例外を捉えることを例外の捕捉と呼びます。


例外処理の基本

Pythonの例外処理は例外が発生する可能性のある箇所をtryブロックに囲み、
exceptで例外の種類を指定して補足します。以下のコードは0で割り算した場合に発生する
例外ZeroDivisionErrorを捕捉し、除数がゼロである旨を表示しています。
"""

x = 1000
y = 0


try:
	z = x / y
	print(z)
except ZeroDivisionError:
	print('除数に0が指定されました。')

"""
上のサンプルでは0除算の例外のみ補足できますが、以下のように例外の種類を省略すると、
全ての例外が補足されます。
"""

try:
	z = x / y
	print(z)
except:
	print('除数に0が指定されました。')

"""
ただし、この書き方は例外捕捉の意図が不明確であるため一般的に推奨されていません。


例外オブジェクトの利用

例外を補足した際にasで例外オブジェクトを変数として指定し、情報を取得することができます。
except 例外クラス as 変数名

例えば例外オブジェクトの情報を参照したい場合は以下のように書きます。
"""

try:
	z = x / y
	print(z)
except ZeroDivisionError as e:
	print('除数に0が指定されました。')
	print(type(e), str(e))

"""
様々な例外と継承関係

例外は上で紹介したZeroDivisionErrorに様々な種類が用意されています。
また、例外クラスは継承関係をもっています。BaseExceptionクラスがすべての例外の親クラスとなります。
次ページで説明する独自例外クラスを実装する際の親となるものがExceptionクラスです。
代表的な組込みの例外の継承関係を以下に示します。

BaseException ←全ての例外の親クラス
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception　←独自例外の親クラス
+-- StopIteration ← イテレータを使用した際に、次の値が無いのにnextした場合に発生
+-- ArithmeticError
| +-- OverflowError ← オーバーフローした場合に発生
| +-- ZeroDivisionError ← 0で除算した場合に発生
|
+-- AssertionError ← アサートエラー
+-- AttributeError ← 存在しない属性を参照した際に発生
+-- ImportError ← インポートに失敗した際に発生
+-- LookupError
| +-- IndexError ← シーケンスに対し存在しないインデックスでアクセスした場合に発生
| +-- KeyError ← 辞書位に対し存在しないキーでアクセスした場合に発生
+-- NameError
| +-- UnboundLocalError
+-- OSError ←システム関連のエラー
| +-- FileExistsError　←　すでに存在するファイルやディレクトリを作成しようとした場合に発生
| +-- FileNotFoundError　←　要求されたファイルやディレクトリが存在しない場合に発生
| +-- PermissionError　←　ファイルアクセス時に十分な権限がない場合に発生
| +-- TimeoutError ←　システム関数がタイムアウトした場合に発生
+-- RuntimeError ← 他のどのカテゴリにも属さないエラーや不明なエラー
+-- SyntaxError ← 文法エラー
| +-- IndentationError ← 不正なインデントがある場合に発生
| +-- TabError ← タブとスペースを一貫しない方法でインデントに使っている場合に発生
+-- TypeError　← 組み込み演算、もしくは関数が適切でない型のオブジェクトに対して適用された場合に発生
+-- ValueError ← 組み込み演算や関数が、正しい型だが適切でない値を受け取った場に発生
+-- Warning ← 警告

5. 組み込み例外より抜粋

捕捉対象に親例外を指定すると、継承した例外も捕捉することが可能です。
例えば、先ほどのサンプルコードではZeroDivisionErrorを使って例外を補足していましたが、
（良し悪しはさておき）かわりにArithmeticErrorやExceptionを使用することも可能です。
同じ理屈でExceptionを指定すると大抵の例外を捕捉することができます。
Pythonの例外は上で紹介したとおり組み込みで多数提供されているため、
公式ドキュメントを参照して適切なものを選ぶようにしてください。


複数の例外を補足する

exceptのブロックを列挙することで複数の例外を捕捉することが可能です。
以下のサンプルでは、辞書に格納された変数x、yで割り算を計算しています。
この処理で発生しうる例外として辞書に値が存在しない、除数が0などが挙げられますが、
それらを複数記述して補足しています。
"""

param = {'x': 1000, 'z': 0}

try:
	x = param['x']
	y = param['y']
	z = x / y
	print(z)

except KeyError as e:    # 辞書に存在しない場合の例外を補足
	print('処理に必要なデータが存在しません')

except ZeroDivisionError as e:    # 0除算を補足
	print('除数に0が指定されました。')

except:    # 全ての例外の補足
	print('原因不明のエラーが発生しました')

"""
else / finally

for文と同様に、tryブロック中で例外が発生しなかった場合、elseブロック内部の処理が実行されます。
また、tryブロック中での例外発生有無にかかわらずfinallyブロックが実行されます。
"""

try:
	z = x / y
	print(z)
except ZeroDivisionError as e:
	print('1')
else:
	print('2')
finally:
	print('3')

"""
例えば、上記コードでyの値が0の場合は例外が発生するため1と3が出力されます。
また、yの値が0以外の場合は例外が起こらず2と3が出力されます。
"""


print("--- Python入門　例外を発生させる---")


"""
例外の送出

例えば、みなさんが作成した関数に対して適切な引数を設定してもらえなかったり、
必要なリソースにアクセスできないような例外的な事象が想定される場合、
必要に応じて例外を発生させる必要がでてきます。Pythonで例外を発生させるにはraise文を使用します。

例外発生
raise 発生させたい例外クラス or 例外オブジェクト

raiseの後には例外クラスでも例外オブジェクトでも指定できます。
例外クラスが渡された場合は、自動的に引数無しのコンストラクタが呼び出されてインスタンス化されます。
また、後ほど例示しますがasと合わせて例外オブジェクトに変数名を指定することができます。

以下のサンプルは独自関数内で例外を発生させるサンプルです。
"""

def sample(num):
	if type(num)!=int:
		raise TypeError('パラメーターが不正です')

	return num * 10

"""
上のコードでは、整数を10倍するsample関数が用意されていますが、
int型以外を引数に指定するとTypeErrorが発生します。
また、引数で任意のメッセージを設定することが可能です。


例外の再送出

例外が発生したことをどこかに記録するだけで、
その処理を処理するつもりがない場合はraiseを利用して補足した例外を再送出することができます。
以下のコードのようにasで例外オブジェクトに別名を付加することが可能です。
"""
"""
x = 1000
y = 0

try:
	z = x / y
	print(z)
except ZeroDivisionError as e:
	print('除数に0が指定されました。')
	raise e
"""
"""
上のコードではexceptで補足した例外にeという変数名を付与し、raiseで再送出しています。

独自例外の定義

前回、組み込みの様々な例外を紹介しましたが、それ以外にカスタマイズした例外を使用したい場合は、
前のページでも少し触れましたが、Exceptionクラスを継承して独自例外を実装します。
通常クラス名はErrorで終わるように命名するのが一般的です。
"""

class ParamError(Exception):

	pass

def sample(num):
	if type(num)!=int:
		raise ParamError('パラメーターが不正です')

	return num * 10

"""
上のコードは先ほどの例外を独自例外に書き換えたものです。
通常のクラスと同様、独自にメンバ変数やメソッドを実装することが可能ですので、
必要に応じてカスタマイズしましょう。
"""


print("--- Python入門　ファイルの読み書き---")


"""
ファイルの読み書き操作の基本
基本フロー

ファイルに対して読み書きといったアクセス操作をする場合、以下の処理が行われます。

    読み/書きのモードを指定してファイルを開く
    ファイルに対して読み/書きの処理を行う
    ファイルを閉じる

組込みのopen関数を使用すると、ファイルを開きファイルオブジェクトを取得することができます。
得られたファイルオブジェクトに対して読み書きを行い、処理が終わったら開いたファイルを閉じます。
ただし、後述するコンテキストマネージャを使用と自動的にクローズが実行されます。

ファイルを開く
変数 = open('ファイルパス', 'モード')

ファイルパスについて、カレントディレクトリはPythonスクリプトを実行した場所となります。

ファイルオープンのモード

ファイルを開く際に指定するモードは4つあります。
モード 	   意味
r 	       読み込み
w 	       書き込み
a 	       追記
b 	       バイナリ
t 	       テキスト（デフォルトでON）

ファイルの読み込み

テキストファイルを読み込んでみましょう。
以下のサンプルコードは実行ディレクトリにsample.txtというテキストファイルを配置してください。
"""

f = open('sample.txt', 'r')    # ファイルを開く
text = f.read()    # ファイルを読み込む
print(text)    # テキストファイルの内容が出力される
f.close()    # ファイルを閉じる

"""
ファイルの書き込み

今度はファイルに書き込んでみましょう。
"""

f = open('sample2.txt', 'w')
f.write('aaaa bbbb cccc テスト書き込み中')
f.close()

"""
sample2.txtというファイルが作成され、３行目に記述した文字列がファイルに書き込まれます。

上のコードでは、実行するたびにファイルの内容が新たに上書きされてしまいます。
追記したい場合は以下のように第２引数に'a'をしていします。
"""

f = open('sample2.txt', "a")

"""
読み書きする

読み込んだ後、書き込みたい場合は以下のようにr+を指定します。
"""

f = open('sample2.txt', 'r+')

"""
文字コードの指定

encoding引数に文字コードを指定することができます。
encodingが指定されていない場合ははプラットフォームに依存します。

対話モードで以下の２コマンドを実行してみてください。
お使いの環境のデフォルトのencodingを調べることができます。

$ python
>>> import locale
>>> locale.getpreferredencoding(False)
'UTF-8'

例えば、sjisを使用したい場合は、以下のように引数に'shift_jis'を指定します。
"""

f = open('sample.txt', 'r', encoding='shift_jis')

"""
with文　コンテキストマネージャ

ファイルを開いた後はcloseが必要ですが、処理中に例外が発生したりするとclose処理が呼び出されず、
予期せぬ結果がファイルに出力されたりロックされたままになったりします。
こういったことを防ぐため、Pythonにはwith文を使用したコンテキストマネージャという仕組みがあります。

with
with open('ファイルパス',  'モード') as 変数名:
    ファイルオブジェクトを扱う処理

以下のサンプルでは、sample.txtを開いて内容を変数textに格納し、printで出力しています。
"""

with open('sample.txt', 'r') as f:
	text = f.read()
	print(text)

"""
途中で例外が発生しても、close処理が自動的に呼びだされます。

以下はwith文の代わりにtry/finallyを使用した例です。
比較してみると明らかにwith文の方がすっきり記述できまることが分かりますね。
"""

try:
	f = open('sample.txt', 'r')
	text = f.read()
	print(text)
finally:
	f.close()


print("--- Python入門　ファイルシステムの操作---")


"""
ファイル/ディレクトリの存在チェック

指定したパスが存在するかどうかはos.path.existsを使用します。
いずれもスクリプトの実行ディレクトリがカレントディレクトリとなります。
また、指定したパスがファイルかディレクトリかの判定はそれぞれ
os.path.isfile、os.path.isdirを使用して得ることができます。
以下のサンプルでは、指定したパスに対して存在するかどうか、
存在する場合はファイルかディレクトリかを判定してメッセージをprintで出力しています。
"""

import os
path = 'sample.py'

if os.path.exists(path):
	print('指定したパスは存在します')

	if os.path.isfile(path):
		print('ファイルです')
	if os.path.isdir(path):
		print('ディレクトリです')
else:
	print('指定したパスは存在しません')


"""
ファイル/ディレクトリの作成と削除
ファイルの削除

os.removeにpathを指定するとファイルの削除ができます。
なお、pathがディレクトリの場合はOSErrorが送出されます。
ディレクトリを削除する場合は後述のrmdirを使用します。
以下のサンプルではカレントディレクトリにあるfile1.txtを削除しています。
"""

# import os
f = open('file1.txt', 'w')
f.write('テスト書き込み中')
f.close()
os.remove('file1.txt')


"""
ディレクトリの作成と削除

単一階層のディレクトリを作成する場合はos.mkdirを、複数階層を作成する場合はos.makedirsを使用します。
また、逆にディレクトリを削除する場合はそれぞれos.rmdir、os.removedirsを使用します。
以下のサンプルではディレクトリの作成と削除を行っています。
"""

# import os

# ディレクトリを作成する
os.mkdir('dir_1')
os.makedirs('dir_2/dir_3')

# ディレクトリを削除する
os.rmdir('dir_1')
os.removedirs('dir_2/dir_3')


"""
ファイル/ディレクトリの移動とコピー

コピーと移動の場合はshutilモジュールを使用します。
単一のファイルかディレクトリの場合はcopyメソッドを、
ディレクトリごと再帰的にコピーする場合はcopytreeメソッドを使用します。
以下のサンプルではそれぞれ単一のファイルのコピーとディレクトリごとのコピーを行っています。
"""

# import os
import shutil


shutil.copy('sample.txt', 'sample2.txt')    # 単一コピー
os.mkdir('dir_1/')
shutil.copytree('dir_1/', 'dir_2/')    # ディレクトリごと再帰的にコピー
shutil.rmtree('dir_1/',)
shutil.rmtree('dir_2/')
