#!/usr/bin/python
# -*- coding: UTF-8 -*-


print("--- Python学習講座 ---")
print("--- Python入門 ---")
print("--- 組み込み関数 代表的な組み込み関数 ---")


print("--- 代表的な組み込み関数 ---")


"""
以下、入門レベルの代表的な組み込み関数を紹介します。
ざっくりとカテゴライズしていますが、あくまでも当サイト固有のものです。
公式にそういった分類があるわけではないため注意してください。
すべての組み込み関数は
https://docs.python.jp/3/library/functions.html
を参照してください。

数学系

計算で使用できる関数です。
"""


print("--- sum() 合計を求める ---")


"""
sum関数を使用するとリストや集合などの
イテラブルなオブジェクトの要素の合計値を計算します。
以下のサンプルは、数値を要素とするリストとsetの合計を算出しています。
"""

l = [1, 2, 3]
s1 = sum(l)
print(s1)    # 6

s = {4, 5, 7}
s2 = sum(s)
print(s2)    # 16


print("--- abs() 絶対値を求める ---")


"""
abs関数を使用すると引数で指定した数値の絶対値を求めることができます。
また、引数に複素数が指定された場合、
複素数の絶対値を取得することができます。
"""

a = abs(100)
print(a)    # 100

b = abs(-99)
print(b)    #  99

c = abs(1j + 3)
print(c)    #  3.1622776601683795


print("--- max()/ min() 最大値/ 最小値を求める ---")


"""
max()、min()は、リストや集合などの
イテラブルなオブジェクトの要素の最大値、最小値を計算することができます。
以下のサンプルは、数値を要素とするリストの最大値と
setの最小値を算出しています。
"""

l = [1, 2, 3]
m1 = max(l)
print(m1)    # 3

s = {4, 5, 7}
m2 = min(s)
print(m2)    # 4


print("--- pow() べき乗計算をおこなう ---")


"""
pow関数でべき乗計算を行うことができます。
以下のサンプルは2の3乗を計算しています。
"""

p = pow(2, 3)
print(p)    # 8

"""
2 ** 3と同等なのですが、
関数オブジェクトとして引数などに渡したりして扱うことができます。
"""


print("--- round() 丸める ---")


"""
round関数を使用すると、引数に丸める対象の数値と、
丸める桁数を指定して最も近い値に丸めた数を得ることができます。
また、丸める桁数を省略した場合は整数が返されます。
以下のサンプルではそれぞれ小数点以下2桁、4桁、0桁（指定なし）
で丸めを行っています。
"""

r1 = round(3.14159, 2)
print(r1)    # 3.14

r2 = round(3.14159, 4)
print(r2)    # 3.1416

r3 = round(3.14159)
print(r3)    # 3


print("--- N進数に変換する ---")


"""
2、8、16進数といったよく使うN進数には組み込み関数で用意されています。

bin() 2進数に変換する

bin関数は引数で指定した整数を2進数に変換します。
"""

b1 = bin(255)
print(b1)    # 0b11111111

b2 = bin(256)
print(b2)    # 0b100000000

"""
oct() 8進数に変換する

oct関数は引数で指定した整数を8進数に変換します。
"""

o1 = oct(255)
print(o1)    # 0o377

o2 = oct(256)
print(o2)    # 0o400

"""
hex() 16進数に変換する

hex関数は引数で指定した整数を16進数に変換します。
"""

h1 = hex(255)
print(h1)    # 0xff

h2 = hex(256)
print(h2)    # 0x100


"""
イテレータに関わるもの

リストなどの繰り返し処理でよく使用する関数です。
"""


print("--- map関数 リストの全て要素に対して同じ処理を行う ---")


print("--- map関数とは ---")


"""
map関数はリストなどのイテラブルオブジェクトな変数に対し、
その全ての要素に指定した関数を実行し、
結果をmap型と呼ばれるオブジェクトで返却します。以下の引数を指定します。
おそらくこれだけだと何のことかわからないと思いますので、
具体的な例を交えて学習してみましょう。

map関数
map(関数オブジェクト, リストなどのイテラブルな変数)
"""


print("--- リストの全ての要素を倍にする ---")


"""
具体例として、リストの全ての要素を倍にする場合について考えてみましょう。
ある数値を倍にして返す関数は以下のように定義できます。
"""

# 数値を倍にする関数
def calc_double(n):
	return n * 2

x = 3
y = calc_double(x)    # 3 * 2で6が格納される
print(calc_double(x))    # 6

"""
さて、あるリストの全ての要素対してcalc_doubleを実行し、
結果を新たなリストとして取得する場合、
map関数を使用すると以下のように記述することができます。
同じ処理をfor文を使った場合と比較してみてください。
"""

# 数値を倍にする関数
def calc_double(n):
	return n * 2

data1 = [1, 3, 6, 50, 5]

# map関数を使用してdata1の要素を全て倍にしてdata2に格納する場合
data2 = map(calc_double, data1)
print(list(data2))    # [2, 6, 12, 100, 10] mapをlistに変換して表示

"""
いかがでしょうか？新たにリストを作成し、ループで回してappendして・・・
という手間が省けます。forを使用すると以下のようになります。
"""

# 数値を倍にする関数
def calc_double(n):
	return n * 2

data1 = [1, 3, 6, 50, 5]

# for文を使って同じことをする場合
data2 = []
for val in data1:
	data2.append(calc_double(val))

print(data2)    # [2, 6, 12, 100, 10]

"""
ただし1点注意があります。
map関数の戻り値はリストではなくイテラブルなmapオブジェクトと呼ばれるものです。
ループ処理は可能なのですが、append等のリストのメソッドは使用できません。
また、print関数で出力しても、カンマ区切りの要素では表示されず、
オブジェクトの型名が表示されるだけです。
ですので、リストにしたい場合はlist関数で変換する必要があります。
"""


print("--- 補足 lambda式と組み合わせる ---")


"""
この手で使用する短い関数をオブジェクトとして扱う場合、
一般的にlambda式を使用することが多いです。
lambda式を使用したものに書き直すと以下のようになります。
"""

data1 = [1, 3, 6, 50, 5]

data2 = map(lambda x: x * 2, data1)
print(list(data2))    # [2, 6, 12, 100, 10] 


print("--- 補足2 実用例 ---")


"""
「リストをカンマ区切りの文字列に変換する」というTIPSに、
実用上よく使用する例を書きました。参考にしてください。
"""


print("--- filter関数 リストから条件を指定して抽出する ---")



print("--- filter関数とは ---")


"""
リストの中から指定条件に合致した要素だけ抽出したい場合がありますが、
そんな場合はfirter関数を使用します。
引数に抽出条件となる関数を指定しますが、これはmap関数とよく似ていますね。
戻り値はイテラブルのfilter型と呼ばれるオブジェクトとなります。
指定する関数は引数に対して何らかの判定を行う、
つまり論理型を返すものを使用します。

filter関数
filter(関数オブジェクト, イテラブルオブジェクト)

では、さっそくサンプルです。
整数のリストに対し、奇数のものだけを抽出する場合を考えてみます。
filter関数を使用した場合、以下のように書くことができます。
"""

def is_odd(n):
	""" 奇数判定関数 """
	return (n % 2) == 1

data1 = [1, 2, 4, 5, 6, 10, 11]
data2 = filter(is_odd, data1)
print(list(data2))    # [1, 5, 11]

"""
data1は整数のリストです。
is_oddは、引数で指定された数値に対し、奇数の場合Trueを返す関数です。
filterでその判定用関数と整数リストを指定して結果を取得しています。
戻り値のfilterオブジェクトの内容を確認するため
7行目でlist関数を一旦はさんでいます。
"""


print("--- 補足 lambda式と組み合わせる ---")


"""
やはりfilter関数もmap関数と同様、lambda式と併用することが多いです。
上記関数をlambda式で書きなおしてみましょう。
"""

data1 = [1, 2, 4, 5, 6, 10, 11]
data2 = filter(lambda x: x % 2 == 1, data1)
print(list(data2))     # [1, 5, 11]

"""
関数定義がなくなった分、スッキリ書くことができましたね。
"""


print("--- zip関数 複数のリストを同時にループで処理する ---")


print("--- zip関数 ---")


"""
複数のリストを同時にループで回したい場合があると思いますが、
そんな場合、zip関数を使用します。
引数にリストを指定すると、反復子が返されます。
サンプルを見てみましょう。
"""

data1 = [1, 2, 3, 4, 5]
data2 = ['a', 'b', 'c', 'd', 'd']

for x, y in zip(data1, data2):
	print(x, y)
# 1 a
# 2 b
# 3 c
# 4 d
# 5 d

"""
特に説明は不要かと思いますが、
実行してみるとdata1、data2のリストの内容が順に出力されます。
リストでなくともイテラブルであれば可能です。
このzip関数ですが、2つどころか3つでも4つでも同時にループ処理が可能です。
例えば3つの場合も同様に、以下のように記述できます。
"""

data1 = [1, 2, 3, 4, 5]
data2 = ['a', 'b', 'c', 'd', 'd']
data3 = ['e', 'f', 'g', 'h', 'i']

for x, y, z in zip(data1, data2, data3):
	print(x, y, z)
# 1 a e
# 2 b f
# 3 c g
# 4 d h
# 5 d i

"""
長さの異なるリスト

また、要素数が同じである必要はなく、
ちゃんと空気を読んで一番短いリストに合わせて処理をしてくれます。
"""

data1 = [1, 2, 3]
data2 = [1, 2, 3, 4]
data3 = [1, 2, 3, 4, 5]

for x, y, z in zip(data1, data2, data3):
	print(x, y, z)     # 3回出力される
# 1 1 1
# 2 2 2
# 3 3 3

"""
例えば上のサンプルの場合、ループ中の処理回数は
一番短いdata1に合わせて3回処理されます。
一方、長い方と合わせたいような場合は
以下のように適当な値で埋める方法があります。

data1 + [None] * (10 - len(data1))
# 長さを10にして、足りない部分はNoneで埋める


ループインデックスの取得 enumerateと組み合わせる

ループインデックスを取得する場合はenumerateを使用しますが、
この場合ちょっと工夫が必要となります。
以下サンプルのとおり、カッコが必要となるので注意してください。
"""

# enumerateと組み合わせる場合
for idx, (x, y, z) in enumerate(zip(data1, data2, data3)):
	# 括弧が必要
	print(idx, x, y, z)
# 0 1 1 1
# 1 2 2 2
# 2 3 3 3


print("--- 組み込み型の関数とstr関数 ---")


print("--- 組み込み型 ---")


"""
変数の型で学んだint、str、list、dict・・・
などPythonに予め用意されている型を組み込み型と呼びます。
これまで同名のint関数、str関数、list関数
といった組み込み関数も登場しましたが、
関数と呼ばれつつ実体は組み込み型です。

    bool()
    bytearray()
    bytes()
    complex()
    dict()
    float()
    frozenset()
    int()
    list()
    object()
    range()
    set()
    slice()
    str()
    tuple()

それぞれ同名の型のオブジェクトを生成しますが、
特に重要なstr関数について補足しておきます。
"""


print("--- str関数 オブジェクトの文字列表現の取得 ---")


"""
str関数は、引数で指定したオブジェクトの文字列表現を返します。
日付や時間、UUID、数式、行列等、Pythonでは様々な型を扱いますが、
最終的に画面やDBなどに出力する際、
文字列で扱う必要が出てくることが多くなります。
便利なことに、よく使われる多くのオブジェクトは
str関数で人間が見やすい形の文字列を取得することができるのです。
例えば、日付/時間で学習した日付型の
datetime.dateの文字列表現を取得してみましょう。
"""

from datetime import date

d = date(2018, 12, 2)
print(str(d))    # 2018-12-02

"""
yyyy-mm-ddの文字列が取得できました。
これはそのオブジェクトのクラスに
特殊メソッド__str__が実装されていることによります。
"""


print("--- reduce関数 シーケンスの値を累積的に集約する ---")


print("--- reduce関数 ---")


"""
reduce関数はリスト等のシーケンスの値を
累積的に計算を行い1つの値に集約します。
1番目の引数に、引数を2つ持つ関数を、
2番目にリスト等のシーケンスを指定します。
日本語の説明よりも、最初にサンプルを読んだほうがわかりやすいでしょう。
以下は、1〜4までの和を求めるサンプルです。
"""

from functools import reduce

def add(arg1, arg2):
    """ 2つの値を足して返す """
    return arg1 + arg2

x = reduce(add, [1, 2, 3, 4])
print(x)    # 10

"""
これはつまり、
add(add(add(1, 2), 3), 4) = (((1 + 2) + 3) + 4) = 
1 + 2 + 3 + 4 と同じことですね。
時系列データ分析等、累積した前回の値を使用する計算でよく使用します。
"""


print("--- 補足 lambda式と組み合わせる ---")


"""
いつもの流れです。
やはり上のような簡単な高階関数を使用する場合は
lambdaを使用したほうが良いでしょう。
"""

from functools import reduce

x = reduce(lambda x, y: x + y, [1, 2, 3, 4])
print(x)    # 10

"""
いつも通り、ずいぶんスッキリ書くことができました。
"""


print("--- 補足2 必ずしも両方の引数を使う必要はない ---")


"""
reduceの一番目の引数は、引数を2つもつ関数を指定しますが、
前回の値から導出できる場合は2番目の引数を使わない場合もあります。
例えば7%の金利で11年間複利で回した場合の計算は以下のようになります。
0年始まりなので、要素数は12を指定しています。
"""

from functools import reduce

def kinri(arg1, arg2):
    return arg1 + arg1 * 0.07

x = reduce(kinri, [100] * 12)
print(x)    # 210.48519522998353

"""
7%複利を11年間回すと2倍になることが確認できます。
（余談ですが金融業界ではこれをセブンイレブンの法則と呼んでいました。）

少々無理やりな説明でしたが、
一部の引数を使わなくて済む場合もある、というわけです。
"""


print("--- hasattr 指定の属性を持つかどうかを検査する ---")


print("--- hasattr ---")


"""
Pythonのオブジェクトは動的に属性を追加したり削除できるため、
「オブジェクトが属性を持つかどうかは(型に依存せず)状況次第」
という特徴があります。
ある程度規模の大きな開発の場合、
データの連携時に期待した属性を
持っているかどうかを確認したくなることが多々出てきますが、
こういった場合hasattrという組み込み関数で事前にチェックをすることができます。
hasattr関数は、第1引数に検査対象オブジェクト、
第2引数に属性名の文字列を指定します。
サンプルで確認してみましょう。
"""

class User():
    """
    ユーザークラス
    """

    def __init__(self, name=""):
        self.name = name

    def say_hello(self):
        print('Hello, my name is ' + self.name)

    def __str__(self):
        return "name:" + self.name

# オブジェクトを生成する
user = User('Kuro')

# ageという属性を持つかどうかを検索する
print(hasattr(user, "age"))
# False

# ageという属性を追加する
user.age = 30

# 再度検査する
print(hasattr(user, "age"))
# True

"""
userというオブジェクトは最初ageという属性を持っていないため、
Falseとなっていましたが、属性追加後はTrueとなっていることが確認できます。
"""


print("--- setattr 属性の追加 ---")


print("--- setattr ---")


"""
オブジェクトに属性を追加することができます。
第1引数に対象となるオブジェクト、第2引数に属性名、
第3引数に属性値を設定します。
"""

class User():
    pass

obj = User()
setattr(obj, "name", "Kuro")

print(obj.name)    # Kuro

"""
.で追加しても良いのですが、setattrはdict型のループと相性が良いです。
よく見かけるテクニックとして、インスタンス生成時に属性が多くなる場合、
引数をdictにして属性を追加する、という方法があります。
"""

class User():
    def __init__(self, attrs):
        for k, v in attrs.items():
            setattr(self, k, v)

obj = User({"name": "Kuro", "age": "30", "memo": "very cool!"})
print(obj.name)    # Kuro

print(obj.age)    # 30

print(obj.memo)    # very cool!

"""
属性が多岐にわたる場合、引数で指定すると膨大になりますが、
この方法ならば可変で様々な属性を付加することができます。
"""


print("--- 補足 getattrとdelattr ---")


"""
補足として、setattrの兄弟、getattrとdelattrを紹介します。

getattr 属性の取得

引数で指定した属性を取得します。
第1引数で対象オブジェクトを、第2引数で属性名を指定します。
また、第3引数でデフォルト値を設定できるのがメリットです。
当該の属性がない場合はデフォルト値が返されるため、
属性存在検査を事前にする必要がなくなるわけです。

例えば、getattr(obj, 'name')は obj.nameと等価となります。
また、objにnameという属性がないことが予想され、
デフォルト値を設定したい場合は
getattr(obj, 'name', 'Nameless')のように記述します。
デフォルト値がなく、指定した属性がない場合
AttributeErrorが送出されます。

delattr 属性の削除

属性を削除することができます。
例えば、objというオブジェクトからnameという属性を削除する場合、
delattr(obj, "name")と記述します。
"""
