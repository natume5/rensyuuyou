#!/usr/bin/python
# -*- coding: UTF-8 -*-


print("--- Python学習講座---")
print("--- Python入門　Lambda式---")


"""
lambda式とは

lambda(ラムダ)式とは、一時的に利用する無名関数を記述する方法で、以下の形式で記述します。

lambda式
lambda 引数: 戻り値

サンプルを見てみましょう。以下のサンプルでは引数xが奇数かどうかを判定した結果を返す関数を
lambda式で記述しています。
"""

func = lambda x: x % 2 == 1

is_odd = func(5)
print(is_odd)    # True

is_odd = func(6)
print(is_odd)    # False

"""
funcには、引数xに対し、引数xが奇数かどうかを判定した結果を返す関数オブジェクトが格納されます。
わかりづらい方は以下にdefを使った場合と比較してみてください。
"""

def is_odd(x):
	return x % 2 == 1

func = is_odd

is_odd = func(5)
print(is_odd)    # True

is_odd = func(6)
print(is_odd)    # False

"""
簡単な関数だと、lambda式で短く書けることがわかりますね。


lambda式のメリット

高階関数

では、短く書ける以外にlambda式を使うと何がいいのでしょうか？
そのメリットを説明する前に、高階関数について説明しましょう。

関数オブジェクトのページで説明したとおり、Pythonの関数はオブジェクトとして扱うことができます。
特に、関数オブジェクトを引数や戻り値にするものを高階関数と呼びます。

高階関数の例
"""

def higher_order(datas, is_target):
	"""高階関数のサンプル"""
	for i in datas:
		if is_target(i):
			print(i)

def is_odd(num):
	return num % 2 == 1

datas = [1, 102, 900, 5, 3]
higher_order(datas, is_odd)

"""
higher_orderは高階関数のサンプルで、引数で指定されたデータリストに対し、
引数で指定された判定ロジックに該当するデータがあればそれをprintで出力する関数です。

上記サンプルでは、判定ロジックに「奇数かどうかを判定する関数」を渡しています。

では、「3の倍数かどうかを判定」する場合はどうすればよいでしょうか？
"""

def higher_order(datas, is_target):
	"""高階関数のサンプル"""
	for i in datas:
		if is_target(i):
			print(i)

def is_multipleof3(num):
	return num % 3 == 0

datas = [1, 102, 900, 5, 3]
higher_order(datas, is_multipleof3)

"""
「3の倍数かどうかを判定する関数」を引数に指定しています。
高階関数自身に修正が入らない点にメリットがありますね。


lambda式のメリット

それではいよいよlambda式の使いどころについてです。
もうお気づきの方も多いと思いますが、
高階関数を利用する際の使いきりの関数でわざわざdefで書くのは面倒です。
そこで、上の高階関数をlambda式で書きなおしてみましょう。
"""

def higher_order(datas, is_target):
	"""高階関数のサンプル"""
	for i in datas:
		if is_target(i):
			print(i)

datas = [1, 102, 900, 5, 3]
higher_order(datas, lambda x: x % 2 == 1)

"""
いかがでしょうか。
関数を短く書けた上、使い捨ての小さい関数がなくなったため、
全体的にスッキリして本筋が読みやすくなったのではないでしょうか？
"""


print("--- Python入門　デコレータ---")


"""
デコレータとは

デコレータとは高階関数を使用して既存の関数に対して機能を追加・変更するための機能です。
元の関数の処理内部に手を加えずに機能を追加・変更できるという点が大きなメリットです。
別ページで解説しますが、クラスにもデコレータを使用することができ、それらと区別する際は関数デコレータと呼びます。

ただし、いきなりデコレータの説明から入ると大抵理解できません。
（実際、デコレータを苦手とする方は多いようです。）

このため、復習を兼ねて順に説明していきましょう。


関数オブジェクトと高階関数の復習

Pythonの関数はオブジェクトとして取り扱いが可能である、という説明を以前しました。
また、引数や戻り値に関数オブジェクトを含むようなものを高階関数と呼びました。
ピンとこない方は以下を復習してください。

関数オブジェクト
内部関数とnonlocal宣言
lambda式

まず、内部関数と組み合わせた高階関数のサンプルを以下に示します。
"""

def deco_func(f):
	def new_func():
		print('start')
		val = f()
		print('end')
		return val

	return new_func


def my_func():
	"""1から10までの合計を返す関数"""
	ret = 0
	for i in range(1, 11):
		ret += i
	print('my_func実行中')
	return ret


f = deco_func(my_func)    # 新たに機能を追加した関数オブジェクトを作成する
x = f()    # 新たに作成した関数を実行する
print(x)

"""
実行結果

start
my_func実行中
end
55

deco_funcは引数で指定された関数に対して処理の前後にstart、
endという文字列の3つを出力するように機能の改変を行ったものを関数オブジェクトとして返しています。
deco_func内をもう少し詳しくみてみましょう。内部でnew_funcという内部関数を定義しています。
このnew_funcは、deco_funcが引数で受け取った関数を実行していますが、その処理に加え、
startという文字列、処理結果、endという文字列の3つを出力しています。
deco_funcはこの内部関数を新たな関数オブジェクトとして返却しているわけです。
新たな関数new_funcを実行すると、処理前後にstart、endが出力され、処理結果が出力されます。


デコレータ

上の高階関数では、元の関数に手を加えずに処理の追加ができている点に注意してください。
さて、この高階関数を常に適用したい場合、どうすればよいでしょうか？そこでいよいよデコレータの出番です。
以下のように処理を追加したい関数の上に@をつけて高階関数を記述します。

デコレータ
@高階関数
def 関数名(引数):
    ：
    ：

デコレータがつけられた関数は常に@以降で指定した高階関数が適用された状態に変化します。
さきほどの関数をデコレータを利用したものに書き換えてみましょう。
"""

def deco_func(f):
	def new_func():
		print('start')
		val = f()
		print('end')
		return val

	return new_func


@deco_func
def my_func():
	"""1から10までの合計を返す関数"""
	ret = 0
	for i in range(1, 11):
		ret += i
	print('my_func実行中')
	return ret


x = my_func()    # 普通にmy_funcを実行すると、deco_funcが適用された関数が実行される
print(x)

"""
デコレータと可変長引数

上のサンプルでは引数なしの関数だけしか使えません。
入門編を通して読まれている方はすぐにピンときたと思いますが、
そう、可変長引数を利用するとこの問題が解決できます。
さらに書きなおしてみましょう。
"""

def deco_func(f):
	def new_func(*args, **kwargs):
		print('start')
		val  = f(*args, **kwargs)
		print('end')
		return val

	return new_func


@deco_func
def my_func(n, m):
	"""nからmまでの合計を返す関数"""
	ret = 0
	for i in range(n, m + 1):
		ret += i

	print('my_func実行中')
	return ret


x = my_func(1, 10)
print(x)

"""
いかがでしょうか？
少し難しいですが、前述の通り元の関数に手を加えずに機能追加ができますので、積極的に活用したいですね。
"""


print("--- Python入門　関数アノテーション---")


"""
まえがき(デコレータではないので注意)

PythonにはJavaのアノテーションのように関数宣言の前に@から始まる文を書くことができ、
これを関数デコレータまたは単にデコレータと呼びますが、ここでは純粋な注釈をいれるアノテーションについて説明します。


関数アノテーション

Python3ではドキュメンテーション文字列に加え、関数の定義部分に引数、戻り値の説明を記述することができます。
以下の構文で記述します。

関数アノテーション
def 関数名(arg1: 'arg1の説明', arg2: 'arg2の説明', , ,)->'戻り値の説明':
    処理

サンプルを見てみましょう。
"""

def my_func(n: 'この値から足し始める', m: 'この値まで足す') -> 'nからmの合計値':
	"""nからmまでの合計を返す関数"""
	ret = 0
	for i in range(n, m+1):
		ret += i

	return ret

"""
引数、戻り値ごとに注釈を記述することができます。
"""


print("--- Python入門　オブジェクトとは---")


"""
オブジェクトとは

「オブジェクトとは」を説明することは論争を呼ぶ話題ですが、
初学者の理解を優先するため少々不正確ですが方便を交えて説明します。

オブジェクトとは、変数の一種なのですが、様々な値や処理を一纏めにしたものと考えてください。
もちろんこの説明だけで理解できる方は少ないと思いますが、
後で説明するクラスを実際に使ってみると理解できるようになると思います。

これまで、数値型やリストといった組み込みの変数を利用してきましたが、
オブジェクトを利用することにより数値型とリストを組み合わせたような変数を定義することができます。
このことにより、現実世界にある具体的なモノを一つの変数として扱うことができます。

つまり、複雑な構造をもった概念を１まとまりとして扱うことができるようになるのです。


クラスとは

そんな便利なオブジェクトですが、作るためにはクラスと呼ばれるテンプレートのようなものが必要になります。

クラスとは「どういうオブジェクトを作るのか」の定義を記述したものです。
大抵のオブジェクトはクラスを元に作られます。

クラスからオブジェクトを作ることを生成と呼びます。
また「インスタンスを生成」と呼称する場合もありますが同じ意味です。


クラスとオブジェクトを使ってみる

では、具体的にクラスを作成し、オブジェクトを生成してみましょう。

まず、以下のオブジェクトを使わないコードを見てみてください。
user1、user2というユーザーを表すそれぞれのデータに対し、
名前と年齢を出力する関数が記述されたプログラムです。
"""

def say(name, age):
	"""指定した内容で挨拶します。"""
	print('私の名前は%sです。%s歳です。' % (name, age),)


# user1を定義
user1_name = 'suzuki'
user1_age = 26

# user2を定義
user2_name = 'sato'
user2_age = 31

# user1の名前と年齢を出力
say(user1_name, user1_age)
# user2の名前と年齢を出力
say(user2_name, user2_age)

"""
このコードをオブジェクトを使用した書き方に変えていきます。
細かい文法は次ページ以降でしますので、まずは概要を理解してください。

1. クラスを定義する

上記プログラムではユーザーの情報として名前と年齢を保持していますので、まずはクラスとして表してみます。
名前と年齢を持ったユーザーを表現する場合は以下のように記述します。

class User(object):
    """"""
    ユーザークラス
    """"""

    def __init__(self, name, age):
        """"""
        初期化
        :param name:名前
        :param age: 年齢
        """"""
        self.name = name
        self.age = age


2. クラスからオブジェクトを生成する

クラスを定義したら次にクラスからオブジェクトを生成します。Userオブジェクトは以下のように生成します。

user1 = User("suzuki", 26)
user2 = User("sato", 31)

名前と年齢をバラバラと定義していたのがスッキリとしました。
3. オブジェクトの情報を読み取る

次に、say関数の引数をUserオブジェクトに変えてみましょう。

def say(user):
    """"""  指定した内容で挨拶します。 """"""
    print('私の名前は%sです。%s歳です。' % (user.name, user.age,))

また、関数の呼び出し部分は以下のように変更します。

# user1を生成
user1 = User("suzuki", 26)
# user2を生成
user2 = User("sato", 31)

今までの変更をまとめると以下のようになります。
"""

class User(object):
	"""
	ユーザークラス
	"""

	def __init__(self, name, age):
		"""
		初期化
		:param name:名前
		:param name:名前
		"""
		self.name = name
		self.age = age


def say(user):
	"""指定した内容で挨拶します。"""
	print('私の名前は%sです。%s歳です。' % (user.name, user.age,))


# user1を生成
user1 = User('suzuki', 27)
# user2を生成
user2 = User('sato', 32)

# user1の名前と年齢を出力
say(user1)
# user2の名前と年齢を出力
say(user2)

"""
Userオブジェクトにより、Userの名前と年齢が一纏めで扱えることができました。


4. メソッドを定義する

また、オブジェクトはデータのみならず処理も一纏めに扱うことができます。
例えば上のsay関数ですが、動作をするのはユーザーですのでオブジェクトにまとめたほうが自然な感じがします。

オブジェクトがもつ関数のことをメソッドと呼びます。
メソッドはクラス内に関数と同じように定義しますが、最初の引数はselfを指定します。
"""

class User(object):
	"""
	ユーザークラス
	"""

	def __init__(self, name, age):
		"""
		初期化
		:param name:名前
		:param age: 年齢
		"""
		self.name = name
		self.age = age

	def say(self):
		"""指定した内容で挨拶します。"""
		print('私の名前は%sです。%s歳です。' % (self.name, self.age))

"""
selfとは生成後の自身のオブジェクトを指します。name、ageを取得する場合はself.name、self.ageのようにアクセスします。


5. メソッドを呼び出す

メソッドを呼び出す場合はオブジェクト.メソッド()で呼び出すことができます。

# user1の名前と年齢を出力
user1.say()
# user2の名前と年齢を出力
user2.say()


6. オブジェクト版のコード

最初のコードを完全に書き換えると以下のようになります。
"""

"""
ユーザークラス
"""

def __init__(self, name, age):
	"""
	初期化
	:param name:名前
	:param age: 年齢
	"""
	self.name = name
	self.age = age

def say(self):
	"""指定した内容で挨拶します。"""
	print('私の名前は%sです。%s歳です。' % (self.name, self.age,))


# user1を生成
user1 = User('suzuki', 25)
# user2を生成
user2 = User('sato', 30)

# user1の名前と年齢を出力
user1.say()
# user2の名前と年齢を出力
user2.say()

"""
ユーザーに関するデータと処理が一つの塊として扱うことができるようになりました。
補足

このページの説明では、クラスを元にオブジェクトを生成しました。
ですが、上のサンプルのようにクラスから生成したもの以外に、
今まで学習してきた数値型や文字列型の変数も実はオブジェクトの一種です。
また、関数やクラス自体もPythonではオブジェクトとして扱われます。
"""
