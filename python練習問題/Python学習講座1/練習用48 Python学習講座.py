#!/usr/bin/python
# -*- coding: UTF-8 -*-


print("--- Python学習講座---")
print("--- NumPy入門  行列の計算 回転行列の計算例---")


"""
肩慣らしとして今回は具体的かつ簡単な行列の計算例として
回転行列による一次変換を取り上げてみます。


回転行列による一次変換

平面座標上の始点(0, 1)に対し、回転行列により30度ずつ回転移動させてみます。
移動させた点をmatplotlibで可視化してみます。

NumPyでは三角関数のsin、cosがnp.sin、np.cosとして提供されていますので
回転行列の各要素でそれらを使用します。

行列の掛け算では前回学習したnp.dotを使用します。
"""

import matplotlib.pyplot as plt
import numpy as np


def get_rotation_matrix(rad):
	"""
	指定したradの回転を返す
	"""
	rot = np.array([[np.cos(rad), -np.sin(rad)], 
	[np.sin(rad), np.cos(rad)]])
	return rot

# 始点
base_point = np.array([1, 0])
x_points = []
y_points = []

for i in range(0, 12):
	deg = i * 30
	rad = deg * np.pi / 180
	rot = get_rotation_matrix(rad)
	rotated = np.dot(rot, base_point)
	x_points.append(rotated[0])
	y_points.append(rotated[1])

fig = plt.figure()
ax = fig.add_subplot(1, 1, 1)
ax.scatter(x_points, y_points)
ax.grid(True)

plt.gca().set_aspect('equal', adjustable='box')
plt.show()


print("--- NumPy入門  基本的な線形代数計算---")


"""
ベクトルや行列の生成、演算など基本的な事柄を学習しました。
ここからは基本的な線形代数の計算方法について学習しましょう。


numpy.linalg

numpy.linalgで基本的な線形代数演算が提供されています。
線形代数の教養課程レベルの教科書によくある以下のトピックをピックアップしました。

実際に手を動かして行列計算すると、だんだん慣れてくると思います。
初学者の方はまずはコピペで動かしてみてください。
基本的な線形代数計算 その1 ノルム・正規化・正規直交化
基本的な線形代数計算 その2 転置・トレース・逆行列・行列式
基本的な線形代数計算 その3 連立方程式
基本的な線形代数計算 その4 固有値

実際に業務などで計算する場合はScipyを使用することが多いのですが、
以前書いたとおりNumPyが基礎となるため、簡単な計算でNumpyの配列の取り扱いに慣れると
今後の学習がスムーズになるかと思います。
"""


print("--- NumPy入門 基本的な線形代数計算 その1 ノルム・正規化・正規直交化---")


"""
ノルムと正規化

ノルム

numpy.linalg.normを使用するとベクトルのノルムを求めることができます。
ピタゴラス数の小さい２数を使用した２次元ベクトルのサンプルを見てみましょう。
"""

# import numpy as np

x = np.array([3, 4])
print(np.linalg.norm(x))   # 5.0

y = np.array([33, 56])
print(np.linalg.norm(y))    # 65.0

"""
斜辺の長さとなっていることが確認できます。３次元以上でも同様です。
"""

# import numpy as np

x = np.array([2, 4, 4])
print(np.linalg.norm(x))    # 6.0


"""
正規化

numpy.linalg.normでノルムが求まりました。長さで割り算すると正規化することができます。
先ほどのサンプルをさらに正規化してみましょう。
"""

# import numpy as np

x = np.array([2, 4, 4])
norm = np.linalg.norm(x)
print(norm)

# ノルムで除算し正規化する
e = x / norm
print(e)    # [0.33333333 0.66666667 0.66666667]

# 正規化を確認する
print(np.linalg.norm(e))    # 1.0

"""
最終的にノルムが1の正規化されたベクトルを算出することができました。


正規直交化

次に２つの基底ベクトルが張るベクトル空間に対し、基底を正規直交化してみましょう。
線形代数の授業などではグラムシュミットの正規直交化を利用したと思いますが、
私も含め難儀された方が多いのではないでしょうか？np.linalg.qrを使用すると
QR分解されたものが返されます。すなわち、任意の正則行列Aが直交行列Qと
上三角行列Rの積に分解されて値が返されるわけです。

3次元ベクトル空間内に基底(1, 1, 0)、(0, -1, 0)が張る部分空間
（つまり３次元空間中のXY平面）があったとします。この基底を正規直交化してみましょう。
"""

# import numpy as np

# 基底(1, 1, 0), (0, -1, 0)
a = np.array([[1, 1], [1, -1], [0, 0]])
print(a)

# [[ 1  1]
#  [ 1 -1]
#  [ 0  0]]

q, r = np.linalg.qr(a)
print(q)

# [[-0.70710678 -0.70710678]
#  [-0.70710678  0.70710678]
#  [-0.         -0.        ]]

print(r)

# [[-1.41421356e+00  3.33066907e-16]
#  [ 0.00000000e+00 -1.41421356e+00]]

"""
QR分解された値が取得できました。
せっかくなので、実際に正規直交なのかを内積とノルムを計算して確認してみましょう。
"""
# 上サンプル続き

# 内積を計算する
ip = np.dot(q[0], q[1])
print(ip)    # -1.1102230246251565e-16


print("%.10f" % ip)    # -0.0000000000


# ノルムを確認する
print(np.linalg.norm(q[0]))    # 0.9999999999999998



print(np.linalg.norm(q[1]))     # 0.9999999999999999→1.0

"""
誤差により厳密には0になりませんので、
内積の方はフォーマットにより小数点表示で丸めて確認しています。
"""


print("--- NumPy入門 基本的な線形代数計算 その2 転置・トレース・逆行列・行列式---")


"""
今回は逆行列、転置、トレース、行列式の取得方法について学習します。
転置、トレースはndarrayオブジェクトのメソッドやプロパティで算出することができます。
逆行列、行列式は前回使用したlinalgを使用します。


転置

プロパティTで行列の転置を取得することができます。いくつかのサンプルで確認してみましょう。
"""

# import numpy as np

a = np.array([1, 2, 3])
print(a.T)    # [1 2 3]

b = np.array([[1], [2], [3]])
print(b)
# [[1]
#  [2]
#  [3]]

print(b.T)    # [[1 2 3]]


c = np.array([[1, 2], [3, 4]])
print(c)
# [[1 2]
#  [3 4]]


print(c.T)
# [[1 3]
#  [2 4]]


"""
トレース

行列の対角成分の和をトレースと呼びます。トレースの算出はtraceメソッドを使用します。
"""

# import numpy as np

a = np.array([[1, 2], [3, 4]])
print(a)
# [[1 2]
#  [3 4]]

print(a.trace())    # 5

"""
(蛇足な気もしますが)、一般的には正方行列のみに定義されるトレース、
numpyでは1,1成分から斜めに行けるところまで計算します。
例外を期待した実装をすると問題を見過ごしてしまうかもしれません。
"""

# import numpy as np

b = np.array([[1, 2, 3], [4, 5, 6]])
print(b)
# [[1 2 3]
#  [4 5 6]]

print(b.trace())    # 6


c = np.array([[1, 2], [3, 4], [5, 6]])
print(c)
# [[1 2]
#  [3 4]
#  [5 6]]

print(c.trace())    # 5


"""
逆行列

linalg.invメソッドで逆行列を求めることができます。
"""

# import numpy as np

a = np.array([[1, 2], [3, 4]])

a_inv = np.linalg.inv(a)
print(a_inv)
# [[-2.   1. ]
#  [ 1.5 -0.5]]

# 検算してみる
print(np.dot(a, a_inv))
# [[1.00000000e+00 1.11022302e-16]
#  [0.00000000e+00 1.00000000e+00]]

"""
最後の計算で行列の積で単位行列になることを確認していますが誤差が発生しています。


行列式

行列式はlinalg.detで求めることができます。
"""

# import numpy as np

a = np.array([[1, 2], [3, 4]])

det_a = np.linalg.det(a)
print(det_a)
# -2.0000000000000004

"""
1 * 4 - 2 * 3 = -2なのでほぼ正しい値が取得できていることが確認できます。
"""


print("--- NumPy入門 基本的な線形代数計算 その3 連立方程式---")


"""
linalg.solve

NumPyのlinalgには連立方程式を解くsolveが用意されています。
引数に連立方程式の係数行列と定数の行列を指定します。

例えば、以下の連立方程式を解く場合を考えます。
\[
\begin{equation}
\begin{cases}
\; 3x+y= 9 \\
\; x+3y= 0
\end{cases}
\end{equation}
\] 連立方程式の変数x、yの係数の及び定数を行列で表すとそれぞれ以下のようになります。

\[
A = \left(
\begin{array}{ll}
3 & 1 \\
1 & 3
\end{array}
\right)
\]

\[
B = \left(
\begin{array}{ll}
9\\
0
\end{array}
\right)
\]

それでは実際にpythonのコードで連立方程式を解いてみましょう。
"""

# import numpy as np

# 係数行列
coef = np.array([[3, 1], [1, 3]])
print(coef)
# [[3 1]
#  [1 3]]

# 定数の行列
dep = np.array([9, 0])
print(dep)    # [9 0]

# 連立方程式の解
ans = np.linalg.solve(coef, dep)
print(ans)    # [ 3.375 -1.125]

"""
念の為検算してみましょう。
"""

print(3 * ans[0] + 1 * ans[1])    # 9.0 

print(1 * ans[0] + 3 * ans[1])    # 0.0

"""
正しい答えが得られていたことが確認できました。
"""


print("--- NumPy入門 基本的な線形代数計算 その4 固有値---")


"""
固有値と固有ベクトル
固有値の復習

固有値の復習からです。

以下のn次の正方行列\( A \)が与えられていたとします。
\[
A = \left(
\begin{array}{llll}
a_{11} & a_{12} & … & a_{1n} \\
a_{21} & a_{22} & … & a_{2n} \\
: & : & … & : \\
a_{n1} & a_{n2} & … & a_{nn}
\end{array}
\right)
\]

この行列に対し、
\[
Ax = \lambda x
\] となる\( x \neq 0 \)が存在する時、\(\lambda\)を\( A \)の固有値と呼びます。
また、\( x \)を固有ベクトルと呼びます。

固有値を自力で計算するには固有方程式の解が必要になりますが、
Numpyではlinalg.eigで算出することができます。


linalg.eig

ではさっそく使ってみましょう。今回はサンプルとして、３行３列の行列を使用してみます。
戻り値はw、vの２つでそれぞれ固有値と固有ベクトルとなります。
"""

# import numpy as np

a = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])
print(a)
# [[2 1 1]
#  [1 2 1]
#  [1 1 2]]

w, v = np.linalg.eig(a)
print(w)    # [1. 4. 1.]


print(v)
# [[-0.81649658  0.57735027 -0.22645541]
#  [ 0.40824829  0.57735027 -0.56613852]
#  [ 0.40824829  0.57735027  0.79259392]]

"""
固有方程式が重解を持つ場合でも、linalg.eigの戻り値は重複した値を返す
という点に注意してください。上の行列の固有値方程式は、
\( (\lambda - 1)^2(\lambda - 4) = 0 \)で1は重解ですが、
wで1が２つ返されています。
vでwの添字に対応した固有ベクトルが返されます。

検算してみましょう。

まずは固有値が１の場合です。固有ベクトルは以下の平面となります。（s、tは任意の数とします。）

\[
x = s \left(
\begin{array}{l}
-0.81649658 \\
0.40824829 \\
0.40824829
\end{array}
\right)
+
t \left(
\begin{array}{l}
0.381008 \\
-0.81590361 \\
0.43489561
\end{array}
\right)
\]

検算は以下のとおりとなります。
"""

l = w[0]    # 固有値1
x = np.array([v[:, 0], v[:, 2]]).T    # 固有ベクトル

print(np.dot(a, x))
# [[-0.81649658 -0.22645541]
#  [ 0.40824829 -0.56613852]
#  [ 0.40824829  0.79259392]]

p = l * x
print(p)
# [[-0.81649658 -0.22645541]
#  [ 0.40824829 -0.56613852]
#  [ 0.40824829  0.79259392]]

"""
元の行列と固有値、固有ベクトルの関係が示されました。

次に固有値が4の場合です。固有ベクトルは以下の通りです。

\[
x = t \left(
\begin{array}{l}
0.57735027 \\
0.57735027 \\
0.57735027
\end{array}
\right)
\]

検算してみましょう。
"""

l = w[1]    # 固有値4
x = np.array([v[:, 1]]).T    # 固有ベクトル

print(np.dot(a, x))
# [[2.30940108]
#  [2.30940108]
#  [2.30940108]]

p = l * x
print(p)
# [[2.30940108]
#  [2.30940108]
#  [2.30940108]]

"""
こちらもやはり元の行列と固有値、固有ベクトルの関係が示されました。


補足

上のサンプルを手で計算するとシンプルに以下のようになります（もちろん計算方法に依存しますが）。

固有方程式
\[
(\lambda - 1)^2 (\lambda - 4) = 0
\] 上を解くと
\[
\lambda = 1, 4
\]

\( \lambda = 1 \)の場合の固有ベクトル

\[
x = s \left(
\begin{array}{l}
-1 \\
1 \\
0
\end{array}
\right)
+
t \left(
\begin{array}{l}
-1 \\
0 \\
1
\end{array}
\right)
\]

\( \lambda = 4 \)の場合の固有ベクトル

\[
x = t \left(
\begin{array}{l}
1 \\
1 \\
1
\end{array}
\right)
\]

ユニークではないため当然といえば当然ですが、
固有ベクトルが教科書通りの値とは異なる点に注意してください。
"""
