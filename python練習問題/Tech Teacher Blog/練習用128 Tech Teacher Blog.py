#!/usr/bin/python
# -*- coding: UTF-8 -*-


print("--- Tech Teacher Blog ---")
print("--- 【Python】classの使い方を理解しよう！役割や実践方法を徹底解説！ ---")
print("--- python3 classの使い方 ---")

"""
「クラスって何だろう」
「クラスっていつ使うの」

そう思った方はいませんか？Pythonを学習すると何度も出会うのがクラスです。
今回は、Pythonのクラスの使い方から実践的な使用方法までの基本を解説します。
初学者の方は、本日の内容が難しいと感じるかもしれませんが、心配しないでください。
経験者でも何度もコードを書き、時間をかけて理解できるのが本日の内容です。
今回はコードを自分で試して、挙動を確認するようにしてください。
"""


print("--- Pythonのクラスとは ---")


"""
「クラス」はよく「設計図」に例えられます。分かりずらい人は料理のレシピと考えると良いでしょう。
何度も同じ味の料理を作るには、食材の種類や量、調味料の調合が決められていると便利です。
同様に決まったデータ処理をするなら、その処理方法が必要なのです。
この決まった処理方法のことを「クラス」と呼ぶのです。


classの役割
クラスを理解する上で、欠かせないのが、「オブジェクト」、「クラス」、「インスタンス」の3つ言葉で、
それぞれに関連があります。
易しく理解するために、「クラス」、「インスタンス」、「オブジェクト」の順に見ましょう。


クラス
クラスは、データを処理するレシピです。私たちは、まずこのレシピを作るのです。
レシピに食材の分量、調理法が書かれているように、クラスにはデータ処理の方法を定義します。
ここが間違えば、間違った結果が生まれます。

インスタンス
クラスというレシピから実際に作った料理を「インスタンス」と呼びます。
インスタンスとは、クラスを実体化させたものです。

オブジェクト
オブジェクトとは、クラスとインスタンスの2つを、まとめた考え方と考えてください。
Pythonでのオブジェクトは「データを抽象的に表したもの」と表現されています。
"""


print("--- classの基本的な使い方 ---")


"""
では、実際のコードを参照しながらクラスの基本的な使い方を見ていきましょう。

クラスの宣言
最初に、クラスを「宣言」します。
次は、最もシンプルな宣言です。
"""


class SampleClass():
	pass

"""
上記のサンプルコードは、「SampleClass」という名前の何の処理もない空のクラスです。

クラスを利用する（インスタンス化する）
Pythonのクラスを利用するには、クラスの中にインスタンスを生成します。
次のサンプルコードは、SampleClassのインスタンスを生成し、クラスのsay()メソッドを呼び出す例です。
"""


class SampleClass():
	def say(self):
		print("Hello World!")

classInstance = SampleClass()
classInstance.say()    # Hello World!

"""
上記のように、クラスのメソッドを呼び出す場合は、
クラスをインスタンス化したものを格納した変数から、
クラスのメソッドを呼び出します。
"""


print("--- Pythonのクラスの実践方法・具体例 ---")


"""
ここからは、より実践的にPythonのクラスの使用方法について解説します。


メソッドを定義する
まずは基本として、クラスの中でメソッドを作る方法を解説します。
メソッドとは、一定の結果を生み出す処理です。
例えば、「野菜を切る」、「炒める」、「調味料の調合」などの各工程の処理を決めるイメージです。
この工程が決まれば、クラスを使うことで画一的処理ができます。
このような小規模な処理の塊をメソッドと呼ぶのです。
これには名前がついており、クラスを利用するときには、メソッド名を使うことで、
メソッド内の処理をまとめて実行できます。Pythonのメソッドは、
”def”キーワードの後に任意のメソッド名を指定します。
"""

class MyClass():
	def sample_method(self):
		# ここにメゾット内の処理を記述する
		pass


"""
Pythonでは、クラスにメソッドを定義する場合、
必ずメソッドの第一引数にクラスのインスタンスを表すオブジェクトを受け取る必要があります。
また、第一引数の名前は「self」とするのが慣習です。
引数は、「いんすう」ではなく、「ひきすう」と呼びます。


引数があるメソッド
次に引数を受け取るメソッドを定義してみましょう。
引数はメソッドの第二引数以降に引数名を記述します。
複数の引数を受け取る場合は、カンマ区切りで引数を宣言します。
"""

class MyClass():
	def sample_method(self, arg1, arg2):
		# ここにメゾット内の処理を記述する
		pass

"""
戻り値を返すメソッド
戻り値とは、処理の結果を示す処理です。
Pythonでは、メソッドに戻り値に関する宣言は必要なく、
処理の中で戻り値をreutrnで返すと、戻り値があるメソッドとして扱われます。


インスタンス変数
インスタンス変数とは、そのインスタンスだけで使う変数です。
クラスのインスタンスが異なれば、それぞれ別の値が格納されます。
次のサンプルコードは、ユーザー名と年齢を格納するインスタンス変数を、クラスに宣言する例です。
また複数のインスタンスを生成し、インスタンスごとに別々の値が保持できることも確認しています。
"""


class MyClass:
	user_name = None    # インスタンス変数の宣言
	age = None    # インスタンス変数の宣言
	def say(self):
		print("名前: {0}、 年齢: {1}".format(self.user_name, self.age))

# 1つ目のインスタンス
user1 = MyClass()
user1.user_name = '山田'
user1.age = 20

# 2つ目のインスタンス
user2 = MyClass()
user2.user_name = '鈴木'
user2.age = 40

user1.say()
user2.say()

# 名前: 山田、 年齢: 20
# 名前: 鈴木、 年齢: 40

"""
コードの実行結果を見ても分かる通り、インスタンス変数にはインスタンスごとに別々の値を保存できます。


コンストラクタ
クラスのメソッドを学習すると、皆さんは、「コンストラクタ」という言葉に出会うと思います。
これは、クラスの初期設定などを行うためのメソッドのことです。
コンストラクタは、クラスのインスタンスを生成した時に自動的に呼び出されます。
コンストラクタは「init」という名前でメソッドを定義します。
では、コンストラクタの宣言方法について解説します。
"""

class MyClass:
	fruits = []
	def __init__(self):
		print('コンストラクタが呼び出されました！')
		# 初期化
		self.fruits.append('パイナップル')
		self.fruits.append('メロン')
		self.fruits.append('イチゴ')

instance = MyClass()
print(instance.fruits)    
# コンストラクタが呼び出されました！
# ['パイナップル', 'メロン', 'イチゴ']

"""
コードを実行すると、次の内容がコンソールに出力されます。
クラスのインスタンスを生成する事で、MyClassのコンストラクタが呼び出されています。
「__init__メソッド」がこれを意味します。


デストラクタ
デストラクタはコンストラクタの逆で、クラスのインスタンスを削除するときに使うメソッドです。
コンストラクタは「del」という名前でメソッドを定義します。
"""

class MyClass:
	fruits = []
	def __del__(self):
		print('デストラクタが呼び出されました！')

# 

"""
クラスを継承する
「継承」とは、元となるクラスのインスタンス変数や、メソッドを別の機能でも使えるようにすることです。
継承したクラスに新しいメソッドを追加したり、元となったクラスのメソッドを拡張したりもできます。
また、継承を使うことで同じような機能のクラスを作る時に、
わざわざ同じような処理を作らなくてよいため、効率的に開発できます。
では、クラスを継承する例を見てみましょう。
"""
"""
# 継承元のクラス
class Base:
	base_val = '継承元のインスタンス変数'

	def base_function(self):
		print('base_function = ' + self.base_val)


# Baseを継承したSubクラス
class Sub(Parent):
	sub_val = '継承先のインスタンス変数'

	def sub_function(self):
		print('sub_function= : ' + self.base_val)
		print('sub_function= : ' + self.sub_val)

sub = Sub()
sub.base_function()
sub.sub_function()
# 
"""


"""
クラスを継承する時のポイントは、継承先のクラスを宣言する時に
「class Sub(Parent):」のように括弧内に継承元のクラスを指定することです。
また、サンプルコードでは、継承先のクラスで新たに「sub_function」定義しており、
その中で継承元のクラスのインスタンス変数を参照しています。
上のサンプルコードを実行すると次のような結果になります。
"""


print("--- まとめ ---")


"""
今回は、Pythonでクラスを宣言する方法と、具体的なクラスの使い方について解説してきました。
Pythonの機能作成で、このクラスの概念は重要で、避けては通れません。
ただ、「正直難しい」と感じた方もいるのではないでしょうか？その感覚は誰もが同じです。
実際に機能を作る経験を繰り返すことでしか、深い納得は得られません。
一つ一つの基本的なコードの挙動をある程度理解すれば、先に学習を進めることをおすすめします。
その後で学ぶ知識と合わさって、今回のクラスの使い方や継承について学習の理解が進みます！
"""



print("--- TechAcademy マガジンより ---")
print("--- Pythonでclass（クラス）を使う方法【初心者向け】 ---")


"""
初心者向けにPythonでclass（クラス）を扱う方法について解説しています。
classはプログラミング全般に必要な知識ですが、習得難易度が高いと感じる人も多くいます。
見慣れない処理が多いかもしれませんが、簡単なプログラムを書いて理解しましょう。
初心者向けにPythonでclass（クラス）を扱う方法について解説しています。
classはプログラミング全般に必要な知識ですが、習得難易度が高いと感じる人も多くいます。
見慣れない処理が多いかもしれませんが、簡単なプログラムを書いて理解しましょう。


今回は、Pythonでclass（クラス）を使う方法を解説します。
classはプログラミング全般で使う技術ですが、習得ハードルが高いと感じる人も多いでしょう。
いきなり難しいことは行わず、簡単なプログラムを扱うところから始めると概念を理解できるはずです。
"""


print("--- Pythonのclassとは ---")


"""
classとは新しいデータの型を作る際の設計図です。
classから生成されたオブジェクト（実体）をインスタンス と呼びます。
classとインスタンスの関係は、よく金型とたい焼きに例えられます。
一つの金型（class）からいろいろな味のたい焼き（インスタンス）が作成できます。
classを作るメリットとして、よく使う処理をclassであらかじめ作成しておくことで、
同じコードを何度も書く必要がなくなります。
DRY（Don’t Repeat Your Self）原則と呼び、
日本語で繰り返し同じ処理を書くことを避ける考えです。
"""


print("--- Pythonのclassの書き方 ---")


"""
class クラス名:
  処理コード

1行目ではclass クラス名:でclassを宣言します。
class名はCapWords形式で宣言します。
CapWords形式とは、最初の1文字は大文字で、その後はキャメルケースを使用します。
キャメルケースとは、アルファベットで複合の単語を組み合わせた命名を行う場合に、
各単語の先頭の文字を大文字で表記します。
例えば、onlineprogrammingschoolであれば、OnlineProgrammingSchoolと記載します。
参考までに一般的に利用されるコーデイングの命名方式は以下の4つです。

・キャメルケース
・パスカルケース
・スネークケース
・チェインケース

これらが利用される命名方式です。
"""


print("--- classの役割と手順 ---")


"""
・コンストラクタ
・メソッド
・インスタンス作成と実行

それぞれの役割と手順を解説します。

2-1. コンストラクタ

コンストラクタとはインスタンスの初期設定を行うメソッドです。
コンストラクタは、クラス内に1つだけ作成できます。
インスタンスとは、抽象的なクラスという概念に、個性を与えて具体化することです。
例えば、「金型」という抽象的なクラスに、個別の商品を指定して個性を与えます。
この「金型から商品を生成する」ことがインスタンス化に当たります。
Pythonにおけるインスタンス化は、「__init__」で行います。
実際にコードを書きます。
"""

class Kanagata:    # クラス作成
	def __init__(self, name):    # コンストラクタ
		self.name = name

"""
「Kanagata」クラスを作成します。
「self.name  =  name」で引数として受け取った値「name」をインスタンス変数
 「name」へ代入して、インスタンス作成時の初期処理として定義しています。
selfはそれぞれのインスタンスを表しますが、そこまで深く考えなくても問題ありません。
決まり文句として理解しましょう。


2-2. メソッド
メソッドとは、プログラムによる実際のふるまいや動作のことです。
コンストラクタはクラス内に1つしか記述できませんでしたが、メソッドは複数作成できます。
「インスタンスメソッド」とも呼ばれます。
メソッドは関数に似ており、defで記述を開始します。
"""

def make(self):
	print('味は' + self.name + 'です')

"""
作成した「make」メソッドは、引数として受け取ったインスタンス変数「name」をprint文で
表示させるように設定しています。


2-3. インスタンス生成と実行
上記クラスを作成し、その中にコンストラクタとメソッドを作成しましたが、それだけでは動作しません。
実際にクラスを動作させるために「インスタンス生成と実行」を行います。
実際にコードを書きます。
"""
"""
Tubuan = Kanagata('tubuan')    # インスタンス生成
Tubuan.make()    # インスタンスの実行
"""
"""
「kanagata」クラスの「name」に「tubuan」を設定し、「Tubuan」インスタンスを生成しています。
生成した「インスタンス名.make()」で make()メソッドを実行しています。
"""


print("--- Pythonのclassをまとめて書いてみよう ---")


"""
クラスを作成します。
"""

class Kanagata:
	# コンストラクタ
	def __init__(self, name):
		self.name = name
	# メソッド
	def make(self):
		print('味は' + self.name + 'です')

"""
インスタンスの作成と実行をします。
"""

Tubuan = Kanagata('tubuan')    # インスタンス生成
Tubuan.make()    # インスタンスの実行
# 味はtubuanです

"""
上記を実行した場合、「味はtubuanです」と表示されるので
Tubuanというインスタンス化に成功しています。
"""


print("--- Pythonのclass継承 ---")


"""
クラスには継承という概念があります。
クラスを継承すると、既存のクラスを引き継いで新たなクラスを定義できます。
以下の例では、「Kanagata」クラスを継承して「Kanagata2」クラスを定義しています。
"""

class Kanagata2(Kanagata):    # Kanagataを継承
	def __init__(self, name, name2):
		super().__init__(name)
		self.name2 = name2
	def make2(self):
		print('ラインナップは' + self.name + 'と' + self.name2 + 'です')

"""
通常のクラス指定は 「class クラス名:」 ですが、継承する場合は、
括弧を追加して親クラス名を中に書く形「class クラス名(親クラス名):」とします。
super().メソッド名() と書くことで、親クラスのメソッドを実行できます。
インスタンスの作成と実行をします。
"""

new = Kanagata2('tubuan', 'koshian')
new.make()    # 味はtubuanです
new.make2()    # ラインナップはtubuanとkoshianです

"""
上記を実行した場合、2行目は「味はtubuanです」と表示され、継承前と同じ結果になります。
3行目は「ラインナップはtubuanとkoshianです」と表示されます。
継承元の「Kanagata」クラスで定義されたメソッドも、
これを継承した「Kanagata2」クラスで定義されたメソッドも、同じように呼び出せます。
このようなクラスの継承を利用すれば、複数のクラスの共通部分を継承元のクラスにまとめられます。
"""


print("--- まとめ ---")


"""
今回は、Pythonでclassを使う方法を解説しました。
プログラミング初心者の間はクラスを自分で作る機会が少ないと思いますが、
インターネットなどで他の人が書いたコードを調べたり勉強したりする時に、
今回紹介した概念を理解しておけば理解力が高まります。
"""



print("--- 【Python入門】クラスの使い方を簡単解説で楽々マスター ---")


"""
Pythonでクラス(class)の使い方を理解したい
そもそもクラスやオブジェクト指向って何？
コンストラクタ？メソッド？継承？ってなに？

プログラミング言語において、「クラス(class)」や「オブジェクト指向」という言葉をよく耳にしますが、
使い方を理解していますでしょうか？クラスを簡単に説明すると、
処理を1つのまとまりとして定義したもので、あらゆるプログラミング言語で使われています。
この記事ではクラスの使い方やコンストラクタ、メソッド、継承などについて理解しておきたい方に向けて、
基本的な内容を解説していきます。

この記事はこんな人のために書きました。

    基本的なクラスの作り方を知りたい
    コンストラクタ、メソッド、継承についても理解しておきたい

クラスについてわかりやすく解説していますので、ぜひ参考にしてください。
"""


print("--- Pythonのクラスとは ---")


"""
Pythonにはクラスという機能があります。このクラスを理解するためには、
オブジェクト指向とは何かについても知る必要があります。
オブジェクト指向とは、基本的にオブジェクト（物）で構成された
プログラミング言語の種類のことを言います。
Pythonではクラスや関数もすべて「オブジェクト」として扱われます。
そして、今回のメインであるクラスを元にして新しくオブジェクトを生成することが出来ます。
"""


print("--- Pythonのクラスの使い方 ---")


"""
では、オブジェクト指向についての基本を学んだら、実際にPythonでクラスを作ってみましょう。

クラスの基本的な構文

Pythonにおけるクラスの基本的な構文はこのようになっています。
"""

class ClassName():
	def __init__(self, ):
		hogehoge

"""
小文字の「class」の後に、好きなクラス名を指定しましょう。
関数では「def」で定義をしていましたが、ここでは「class」になります。
引数は、今回は空欄にしておきましょう。
そしてclassから始まる構文の内部に「__init__」という関数が定義されています。
これはコンストラクタという、クラスの中でも重要な機能になります。
コンストラクタについては次の章で解説します。
"""


print("--- コンストラクタとは ---")


"""
コンストラクタとは、「__init__」という名前の部分です。
コンストラクタは、インスタンスを作成する際に重要な処理を含むものです。
どのように生成するか、どのようなデータを持たせるかなど、
といった情報を定義するのに必要なメソッドになります。
引数にselfというものがあるのに注意してください。
selfとはインスタンス自身を指し、
基本的にはこの引数は必須なので忘れないように気を付けてくださいね。
では実際にクラスを作成してみましょう。こちらのコードを見てみましょう。
"""

class MyClass():
	def __init__(self, message):
		self.value = message

myinstance = MyClass('Hello!')
print(myinstance.value)
# Hello!

"""
こちらのコードでは、コンストラクタの引数にselfとmessageを指定しました。
このインスタンスのデータにmessageを追加したいので、valueという属性（アトリビュート）を追加し、
第二引数のmessageを代入したのです。
そしてインスタンスを生成するために、インスタンスを代入する変数名 = クラス名(引数)と、
呼び出しました。ご覧いただけるように、ちゃんと「Hello!」と表示されましたね。


メソッドとは

コンストラクタという特別なメソッドの定義方法をご紹介しました。
この章では、インスタンスの振る舞いや行動を表現するメソッドの定義方法をご紹介したいと思います。
メソッドとは、クラス内に定義された関数のことです。
メソッドは定義されたクラスからしか呼び出すことが出来ないのも、特徴の一つです。
"""

class Example():
	def __init__(self, a, b, c):
		self.num1 = a
		self.num2 = b
		self.num3 = c

	def print_tot(self):
		tot = self.num1 + self.num2 + self.num3
		print(tot)

myinstance = Example(1, 2, 3)
myinstance.print_tot()    # 6

"""
上のコードでは、Exampleという名前のクラスを定義しました。
Exampleはコンストラクタとprint_totというメソッドのみを含んでいます。
コンストラクタでは引数に指定したa、b、cを属性num1、num2、num3に代入しています。
そして、print_totは生成したインスタンスが持つ属性三つの合計を計算し、出力します。
実際、myinstanceを引数1、2、3で作成したところ、合計は6と表示されました。


継承とは

プログラムを書いていると、あるクラスを元にその派生クラスを作りたい場合があると思います。
そのようなケースでは、継承を使用すると便利です。
"""

class Oya():
	def oya_func(self):
		print('I am OYA')

class Kodomo(Oya):
	def kodomo_func(self):
		print('I am Kodomo')

K = Kodomo()

K.oya_func()
K.kodomo_func()
# I am OYA
# I am Kodomo

"""
こちらのコードでは、Oyaクラスを元にKodomoクラスを作成しました。
継承では、継承先となる子クラスの引数に、親クラスを渡しています。
継承を行っているので、Kodomoクラスのインスタンスは
自分が所有しているkodomo_funcというメソッドに加え、
Oyaクラスのoya_funcまでも呼び出せるのです。
"""


print("--- まとめ ---")


"""
今回は、Pythonにおけるクラスの基本をご紹介しました。
覚えておきたいポイントは

    コンストラクタを定義する際はselfを引数に指定するのを忘れない！
    メソッドは関数なのでdefキーワードを使用する
    あるクラスをベースに新しいクラスを作りたい場合は継承！

こんな感じですね。
この記事を通してクラスについての知識をどんどん深めていってください！
"""


print("--- Qiitaより ---")
print("--- 【Python入門】Pythonにおけるclassの使い方とは? ---")


"""
※こちらの記事は、プロスタ編集部が現在大変人気の高いPythonの文法記事を公開することで、
皆様の学習にお役に立ちたい意図で投稿しております。

参考サイト：【Python入門】Pythonにおけるclassの使い方とは?

Pythonはオブジェクト指向プログラミングをサポートしている言語です。
そのためにはクラスを定義、作成することが必要です。
Pythonのクラス定義は他の言語と比べると簡単に行えるようになっています。
今回は、Pythonにおける基本的なクラスの扱いについて説明します。


クラスの定義

Pythonではクラスの定義にclass文を使用します。
class文を使った定義の仕方は以下のようになります。

class クラス名:

class文の後にそのクラスの名前となるクラス名をつけて、最後に「:」を付け加えます。
そのあとに一段落インデントを入れてクラス定義をしていきます。
"""

class Test:
	pass    # 何もしないクラスの場合はpassと記入する

test = Test()    # インスタンスを生成

"""
メソッド

クラスにはメソッドを定義することができます。
メソッドの定義は以下のように行います。

class クラス名:

    def メソッド名(self):
        #メソッドの定義

メソッドは必ず1つ以上の引数を持ちます。
また、引数のうち最初のものはselfという名前にすることになっています。
メソッドを呼び出すには以下のようにします。

インスタンス.メソッド名()
"""

class Test:

	def test_print(self):
		print('This is test')

test = Test()    # インスタンスを生成
test.test_print()    # メソッド呼び出し
# This is test

"""
コンストラクタとデストラクタ

メソッドの中でも、インスタンスが生成されるときに自動的に呼び出されるメソッドのことを
コンストラクタと言います。
コンストラクタを定義するには「init」という名前のメソッドを作成します。

class Test:
    def __init__(self, 引数1, 引数2, ….):
        #コンストラクタの定義

initも必ずselfという引数が必要になります。
それ以外にも引数をつけることができ、その引数はインスタンスを生成する際に
クラスを呼び出す時の引数が渡されます。
"""

class Test:
	def __init__(self, num):
		self.num = num    # このクラスが持つ「num」変数に引数を格納

	def print_num(self):
		print('引数で渡された数字は{}です。'.format(self.num))

test = Test(10)    # ここで渡された引数が__init__のnumに渡される
test.print_num()
# 引数で渡された数字は10です。

"""
コンストラクタとは逆に、インスタンスが不要になり削除される時に呼ばれるメソッドを
デストラクタと言います。
デストラクタは「del」という名前のメソッドで定義されます。
"""

class Test:
	def __init__(self):
		print('コンストラクタが呼ばれました')

	def __del__(self):
		print('デストラクタが呼ばれました')

test = Test()    # インスタンスを生成
del test    # インスタンスを削除
# コンストラクタが呼ばれました
# デストラクタが呼ばれました

"""
継承

Pythonのクラスも他のクラスを継承し、拡張することができます。
クラスを継承する場合はクラス文に親となるクラスを指定します。
親のクラスのメソッドを呼び出す場合はsuper()を使います。
"""

class Test:
	def __init__(self, num):
		self.num = num

	def print_num(self):
		print('引数で渡された数字は{}です。'.format(self.num))


class Test2(Test):    # Testクラスを継承
	def print_test2_info(self):
		print('このクラスはTestクラスを継承しています。')
		super().print_num()    # 親クラスのprint_num()を呼び出す

test = Test2(10)
test.print_test2_info()
# このクラスはTestクラスを継承しています。
# 引数で渡された数字は10です。




print("--- TRAINOCAMPより ---")
print("--- Pythonのクラス（class）の基本を徹底解説、具体的な書き方も ---")


"""
class（クラス）とは
オブジェクトの内容を記述しておく仕組みがclassです。classとは「ひな型」です。
ひな型の中に、データを入れる領域、処理の仕方を書く領域を設けます。
classが持つデータへの直接的な操作はclassの中で完結します。
しかし、実際のプログラミングではclassが持っているデータを
外部から直接操作するのが手っ取り早いときもあるので、
Pythonはその手段も提供しています。
臨機応変にclassを設計できるのがPythonのclassの特徴です。


メソッドとは

classの中で、処理の仕方を書いてある部分を「メソッド」と呼びます。
実際には、Pythonのclassの「メソッド」は関数です。
classの「メソッド」の中では自身のデータを参照できます。


インスタンス化とは

classとは「ひな型」と書きました。
では、現実にデータを格納するときはどうやるのでしょう？
それが、「インスタンス化」です。
「インスタンス」とは、ひな型から実際のデータを格納したものを作り、データを保存しておくものです。
"""


print("--- Pythonにおける「class（クラス）」の使い方 ---")


"""
classの定義

この記事では、以下のclassを元に解説していきます。
"""

class SimpleData:
	a = 0
	b = 0

	def sum(self):
		return self.a + self.b

	def set(self, a, b):
		self.a = a
		self.b = b

"""
このクラスSampleDataはデータを二つ持っています。aとbです。
それに対して、メソッドを二つ持っています。合計値を返すsumと、aとbに値をセットするsetです。
なおselfは「自分自身」という意味です。
メソッドの引数にあるselfですが、メソッドは第一引数にselfを書くというルールが決まっています。
ここでは深く考えず、こういうものだと認識してください。
それに対して、

        self.a = a
        self.b = b

の左辺にあるselfとは、自分自身の変数に、という意味になります。
引数でもらったaを自分自身のaに、bを自分自身のbに代入する処理になっています。
self.aとa、self.bとbは全く違う変数ですので注意してください。
同じ名前が付けられているだけで、全くの別物です。


classのインスタンス化とインスタンス変数

ではこのSimpleDataを使う際にはどのようにすればいいのでしょうか？それが、「インスタンス化」です。
"""

data1 = SimpleData()
data2 = SimpleData()

"""
のようにして、SimpleDataに実際データが入ったものを作ってやります。

"""

data1 = SimpleData()
data1.set(1, 2)
print(data1.sum())

# 3

"""
このようにして、「.」の後にメソッド名を続けてメソッドを呼び出します。ここで問題です。
以下のコードを実行すると、結果はどうなるでしょうか？
"""

data1 = SimpleData()
data2 = SimpleData()
data1.set(1, 2)
data2.set(3, 4)
print(data1.sum())
print(data2.sum())
# 3
# 7

"""
です。

どうしてこうなるのでしょうか？それは、data1とdata2は別々のインスタンスだからです。
お互いに何の関係もありません。データは別々に保持されています。
data1やdata2のことを「インスタンス変数」と呼びます。
メソッドの中では、selfで自身の持つデータにアクセスできます。
また引数でもらった変数を参照することもできます。
メソッドを定義するとき、classから一つインデントを下げてdefを書き、
更にインデントを下げてdefの中の処理を書きます。
Pythonではまとまりごとにインデントで区別するのでしたね。メソッドもまたまとまりです。


コンストラクタとは

コンストラクタとは、「インスタンス化されたときに最初に呼ばれる特別なメソッド」です。
データの初期化の処理を書きます。SimpleDataにコンストラクタを付けましょう。

    def __init__(self):
        self.a = 0
        self.b = 0

メソッドでは第一引数はselfでした。このように書くと、クラスのデータであるaとbが0に初期化されます。
この__init__というコンストラクタを作ると、SimpleDataは次のように書き直せます。
"""

class SimpleData:

	def __init__(self):
		self.a = 0
		self.b = 0

	def sum(self):
		return self.a + self.b

	def set(self, a, b):
		self.a = a
		self.b = b

"""
どこにもaとbがないと思うかもしれませんが、__init__の中にself.aとself.b
という記述があることにより、そこでデータ領域が作られるのです。
つまり、
"""

data1 = SimpleData()
print(data1.sum())    # 0

"""
となります。コンストラクタは複数持つことができ、引数を与えることもできます。
"""

class SimpleData:

	def __init__(self):
		self.a = 0
		self.b = 0

	def __init__(self, a, b):
		self.a = a
		self.b = b

	def sum(self):
		return self.a + self.b

	def set(self, a, b):
		self.a = a
		self.b = b

"""
def __init__(self, a, b)はaとbを与えてその値で初期化するコンストラクタです。
次のように使います。

data1 = SimpleData(1, 2)

このコードだと、aは1に、bは2に初期化されます。
"""

data1 = SimpleData(1, 2)
print(data1.sum())
# 3

"""
となります。どのコンストラクタが呼ばれるかは、引数の数で自動判定されます。


デストラクタとは

反対に、インスタンスが破棄されたとき（正確に言うと、どこからも参照されなくなったとき）
に呼ばれる特別なメソッドを定義することもできます。それをデストラクタと呼びます。
"""

class SimpleData:

	def __init__(self):
		self.a = 0
		self.b = 0

	def __init__(self, a, b):
		self.a = a
		self.b = b

	def __del__(self):
		print('インスタンスが破棄されました')

	def sum(self):
		return self.a + self.b

	def set(self, a, b):
		self.a = a
		self.b = b

"""
と書くと、
"""

data1 = SimpleData(1, 2)
print(data1.sum())
data1 = None

"""
は
"""

# 3
# インスタンスが破棄されました

"""
インスタンスが破棄されました

となります。

実際にはデストラクタを使うことはあまりないですが、
コンストラクタでファイルを開いていたとか、何かのリソースを予約している場合、
そのリソースの破棄の処理をデストラクタに書いたりします。


classの継承とは

classは「継承」できます。耳慣れない言葉が出てきたと思ったかもしれません。
「継承」とは、「より一般的なclassを受け継いで、より専門的なclassを作ること」です。
SimpleDataを「継承」してclassを作ってみましょう。
"""

class ComplexData(SimpleData):

	def __init__(self):
		super().__init__()
		self.c = 1

	def __init__(self, a, b):
		super().__init__(a, b)
		self.c = 1

	def sum(self):
		return self.a + self.b + self.c

"""
一気に難しくなりました。一つひとつ解説します。

    def __init__(self):
        super().__init__()
        self.c = 1

は引数なしでインスタンス化されたとき呼ばれるコンストラクタです。
super()でSimpleDataのメソッドが呼べます。
ここではSimpleDataの引数なしのコンストラクタを呼んでいます。

そしてその後、cに1をセットします。

    def __init__(self, a, b):
        super().__init__(a, b)
        self.c = 1

は引数ありでインスタンス化されたとき呼ばれるコンストラクタです。
ここではSimpleDataの引数ありのコンストラクタを呼び、cに1をセットしています。
そう、このComplexDataでは、cの値を外から初期化することはできないのです。

    def sum(self):
        return self.a + self.b + self.c

は合計値を返すメソッドです。SimpleDataのaとb、自身のcを合計して返しています。
setが見当たりませんね。
"""

data3 = ComplexData(1, 2)
data3.set(1, 2)
print(data3.sum())    # 4

"""
と書いたとき、cの値はどうなるのでしょう？
実は、このときはSimpleDataのsetが呼ばれて、aとbがセットされるだけなのです。
cの値を変えるメソッドはどこにもありません。
これが、「不変項としてcを付加した特別なSimpleData」であるComplexDataという
「特別なクラス」です。継承はこのようにやや難しいですが、
実際のPythonのプログラミングではよく登場します。
押さえておいていください。
"""


print("--- Pythonでclassを扱う際の注意点やコツ ---")


"""
classは何段階でも継承ができますが、あまり細かい単位で変更して継承を繰り返すと、
継承元がどこまでも遡れるようになり、どのクラスのデータを参照しているのか、
どのクラスのメソッドが呼ばれているのか分からなくなります。これを「継承地獄」と言います。
本当に処理が変わったときにのみ継承するようにした方がいいでしょう。
また、名前の付け方ですが、Pythonの命名規則では変数名や関数名は

xxxx_xxxx_xxxx

というように小文字のアルファベット・数字を「_」でつなげて記述するのが推奨されていますが、
クラスは

XxxxXxxx

というように大文字のアルファベットで単語を始めて残りは小文字にし、
それをただ連結する記述が推奨されています。
この命名規則に従うことを推奨します。
"""



print("--- 日経クロステックより ---")
print("--- Pythonの「クラス」を理解、オブジェクト指向プログラミングの基本を押さえる ---")


"""
Pythonは、オブジェクト指向プログラミング言語の1つです。
オブジェクト指向とは、値やそれを扱うためのソースコードをまとめて
「オブジェクト（物）」として扱う考え方です。
　オブジェクトを表現するために重要な機能が、「クラス」です。
クラスは、オブジェクトを生成するときのひな型のようなものです。
今回は、クラスについて理解を深めましょう。


クラス
クラスの定義

　クラスを定義するための基本的な構文は以下の通りです。

class ClassName:
    def __init__(self, 引数2……):
        pass

　小文字の「class」の後に、好きなクラス名を指定します。
関数は「def」というキーワードで定義しましたが、クラスは「class」で定義します。
　クラスの内部に、「__init__」という関数が定義されています。
これは「コンストラクタ」という、クラスの中でも重要な機能です。


コンストラクタ、メンバ

　コンストラクタは、オブジェクト生成時に最初に実行される、「初期化用の特殊な関数」のことです。
Pythonでは、コンストラクタは、「_init_（）」という名前で定義するのがルールです。
　コンストラクタを呼び出すことで、
当該のクラスのオブジェクト（「インスタンス」と呼ぶ）を生成できます。
コンストラクタは、この生成時に1度だけ実行されます。
　コンストラクタの第1引数には、「self」を指定します。
「self」は、コンストラクタによって生成されるオブジェクト自身を示しています。
コンストラクタを呼び出す際には第1引数を指定する必要はなく、第2引数から記述します。
　「メンバ」についても覚えておきましょう。メンバは、クラス内で使用する変数のことです。
　例として、「Human」クラスを定義してみます。
メンバとして、「name」「year」という変数を用意しています。
それぞれ、氏名と年齢を格納する変数です。
"""

# Humanクラスを定義
class Human:

	# コンストラクタを定義
	def __init__(self, name, year):

		# メンバ
		self.name = name
		self.year = year

"""
なお、Javaなど他のオブジェクト指向言語では、
メンバには「プライベート（インスタンス外からアクセスできない）」と
「パブリック（インスタンス外からもアクセスできる）」の2種類があるものがあります。
しかしPythonでは、メンバは全てパブリック、つまりインスタンス外からアクセス可能です。
アクセスを制限したいときは、「プロパティ」という手法を使います。
　では、定義したクラスをインスタンスを生成しましょう。 
インスタンスを生成する際は、クラス（ここではHuman）を呼び出します。
引数には「Kawada」「26」を指定します。
"""

# Humanを呼び出し、human1を作成
human1 = Human('Kawada', 26)

"""
Humanクラスを呼び出すと、Humanクラスのコンストラクタが実行されます。
メンバの「name」「year」が初期化され、
それぞれに引数として渡された「Kawada」「26」が代入されます。
　インスタンスのメンバは、 「（オブジェクト）.（変数名）」で参照できます。
"""

# human1のnameを出力(「Kawada」が出力される)
print(human1.name)    # Kawada

# human1のyearを出力(「Kawada」が出力される)
print(human1.year)    # 26

"""
メンバの変更も可能です。
"""

# メンバを書き換え
human1.name = 'morimoto'

# human1のnameを出力
print(human1.name)    # morimoto
# インスタンスが破棄されました


"""
メソッド

　メソッドとは、処理のまとまりに名前を付けたものです。
同様のものに関数がありますが、クラスが備える関数をメソッドと呼ぶと理解すればよいでしょう。
　以下では、Humanクラスに「introduce（）」というメソッドを定義しています。
"""

# class宣言
class Human:

	# コンストラクタ
	def __init__(self, name, year, birth):
		self.name = name
		self.year = year
		self.birth = birth

	# 自己紹介メソッド
	def introduce(self):
		text = '私の名前は、{}です。今年で{}歳になります。'
		return text.format(self.name, self.year)

"""
メソッドの呼び出しは、「（オブジェクト）.（メソッド名）」と記述します。
"""

# インスタンス作成
souma_human = Human('souma', 26, '19931013')
# 自己紹介メソッド呼び出し
souma_introduce = souma_human.introduce()
# 出力
print(souma_introduce)    # 私の名前は、soumaです。今年で26歳になります。

"""
これを実行すると、「私の名前は、soumaです。今年で26歳になります。」と表示されます。
　メソッドに引数を渡すこともできます。以下のgrow_old（）メソッドを参照してください。
引数で指定された数を、年齢に加算するメソッドです。
"""

# class宣言
class Human:

	# コンストラクタ
	def __init__(self, name, year, birth):
		self.name = name
		self.year = year
		self.birth = birth

	# 自己紹介メソッド
	def introduce(self):
		text = '私の名前は、{}です。今年で{}歳になります。'
		return text.format(self.name, self.year)

	# 加齢メソッド
	def grow_old(self, after):
		self.year += after

# インスタンス作成
souma_human = Human('souma', 26, '19931013')
print(souma_human.introduce())    # 私の名前は、soumaです。今年で26歳になります。
# 加齢メソッド呼び出し
souma_human.grow_old(2)
print(souma_human.introduce())    # 私の名前は、soumaです。今年で28歳になります。

"""
これを実行すると、以下が出力されます。
引数の「2」の数だけ、年齢が上がりました。


継承

　プログラミングを進めていると、既存のクラスに機能を追加したいケースが出てきます。
ソースコードを調節変更してしまうと、同じクラスを試用している別のプログラムに
影響が出る可能性があります。
　既存のクラスのソースコードをコピーして別のクラスを新しく定義することもできますが、
同じようなクラスが2つ存在することはあまり好ましい状態ではありません。
　そこでPythonをはじめとするオブジェクト指向言語には、継承（インヘリタンス）
という仕組みが用意されています。 
継承を利用することで、既存のクラスをコピーしたり直接上書きしたりすることなく、
メソッドやメンバの追加や上書きが可能になります。
　継承元となるクラスを「親クラス」や「スーパークラス」、「基底クラス」などと呼びます。
継承先のクラスは「子クラス」「サブクラス」、「派生クラス」と呼びます。

以下のソースコードでは、Humanクラスと、それを継承した「HumanHealth」クラスを定義しています。
"""

# class宣言
class Human:

	# コンストラクタ
	def __init__(self, name, year, birth):
		self.name = name
		self.year = year
		self.birth = birth

	# 自己紹介メソッド
	def introduce(self):
		text = '私の名前は、{}です。今年で{}歳になります。'
		return text.format(self.name, self.year)

	# 加齢メソッド
	def grow_old(self, after):
		self.year += after

# Humanクラスを継承して、HumanHealthを定義
class HumanHealth(Human):
	# コンストラクタ
	def __init__(self, name, year, birth, height, weight):

		# 親クラスのコンストラクタを呼び出す
		super().__init__(name, year, birth)

		self.height = height
		self.weight = weight

	# BMIメソッドを追加
	def get_bmi(self):
		return round(self.weight / (self.height ** 2), 2)

"""
HumanHealthクラスのコンストラクタの冒頭に、「super（）」という記述があります。
これで、親クラスのコンストラクタを呼び出すことができます。
その上で、「height」「weight」というHumanHealthクラス独自のメンバに
値を設定する処理をしています。
　このクラスでインスタンスを生成してみましょう。
"""

souma = HumanHealth('souma', 26, '19931013', 1.7, 70)
# 子メンバ
print(souma.height)    # 1.7
# 子メンバ
print(souma.weight)    # 70
# 子メソッド
print(souma.get_bmi())    # 24.22
# 親メソッド
print(souma.introduce())    # 私の名前は、soumaです。今年で26歳になります。

"""
親クラスにはなかったheight、weightを設定した上で、それらを用いてBMI値を算出しています。
　なお、子クラスは親クラスの機能を継承しているので、
親クラスのメンバやメソッドも呼び出せます。
上の例では、introduce（）メソッドを実行しています。


オーバーライド

　オーバーライドとは、クラスを継承する際に、親クラスのメソッドを上書きすることです。
子クラスで、親クラスと同じメソッド名で定義し直します。
　以下の例では、子クラスであるHumanHealthクラスで、
親クラスのintroduce（）メソッドをオーバーライドしています。
自己紹介の内容として、BMIを追加しています。
"""

# class宣言
class Human:

	# コンストラクタ
	def __init__(self, name, year, birth):
		self.name = name
		self.year = year
		self.birth = birth

	# 自己紹介メソッド
	def introduce(self):
		text = '私の名前は、{}です。今年で{}歳になります。'
		return text.format(self.name, self.year)

	# 加齢メソッド
	def get_name(self):
		return self.name

# Humanクラスを継承して、HumanHealthを定義
class HumanHealth(Human):
	# コンストラクタ
	def __init__(self, name, year, birth, height, weight):

		# 親クラスのコンストラクタを呼び出す
		super().__init__(name, year, birth)

		self.height = height
		self.weight = weight

	# BMIメソッドを追加
	def get_bmi(self):
		return round(self.weight / (self.height ** 2), 2)

	# 自己紹介メソッドをオーバーライド
	def introduce(self):
		text = '私の名前は、{}です。今年で{}歳になります。BMIは{}です。'
		return text.format(self.name, self.year, self.get_bmi())

"""
オーバーライドする際には、親クラスとメソッド名を同じにします。
さらに、メソッドの引数の数も同一にして、順番も同じにする必要があります。
　では、オーバーライドしたメソッドを呼び出してみましょう。
"""

souma = HumanHealth('souma', 26, '19931013', 1.7, 70)
# オーバーライド
print(souma.introduce())    # 私の名前は、soumaです。今年で26歳になります。BMIは24.22です。

"""
「私の名前は、soumaです。今年で26歳になります。BMIは24.22です。」と出力されます。
　このように、子クラスであるHumanHealthのintroduce（）が実行されているのが分かります。
　オーバーライドは、既に存在するクラスの特定のメソッドを変更して使いたい場合などに便利です。
変更したいメソッドを記述し直すだけで済み、
メンバや他のメソッドを改めて記述する必要がないのが利点です。
"""



print("--- python使うけどclassはよくわからん、のでチュートリアルするより ---")


"""
pythonは使うけどclassとかよくわからん。
でもpytorchにclassが頻出なので勉強する必要がある。
同じような立場の人が心理障壁を下げるために使っていただけたらと思う。
正しい理解は公式ドキュメント9:classを参照してください。


とりあえず関数「def」

処理したい操作に名前と引数を指定することができる。
"""

def Kakezan(a, b):
	return a * b

print(Kakezan(9, 9))    # 81

"""
実行結果は次のようにして変数に保存できる。
"""

times99 = Kakezan(9, 9)


"""
classについて一番かんたんな構造で考える

ただの情報の値の入った箱と考える
"""

class Keisan:
	num1 = 1
	num2 = 2

"""
クラスの中の情報をドット記号を使って取り出すことができる。
"""

Keisan.num1

"""
引数とイコールで結ぶと、情報の入った箱を移し替えるようなイメージで扱える
"""

box1 = Keisan()
print(box1)    # <__main__.Keisan object at 0x0000026C18874C40>

"""
クラスの名前が出力される
"""

box1.num1

"""
中身をドットで取り出すことができる。


box1というオブジェクトの変数を書き換える
"""

box1.num1 = 10
print(box1.num1)    # 10


"""
コンストラクタ

オブジェクトが生成される時に必ず実行されるメソッド（class内の関数）のこと
"""

class Keisan:
	num1 = 1
	num2 = 2
	def __init__(self):
		print('必ず表示される')

box3 = Keisan()    # 必ず表示される

"""
classを変数に入れるとコンストラクタ部分が実行される

上記のselfは必ず書くおまじないである
selfがさしている対象は上記であればbox3
今は処理が何もないが、必ずなにか引数を入れなさい。という指示にも使える
"""

class Keisan:
	num1 = 1
	num2 = 2

	def __init__(self, name1, age1):
		print('一人目の名前は' + name1 + 'で年齢は' + str(age1) + 
			'です。これは毎回表示されます。')

box4 = Keisan(name1='Mike', age1=19)

"""
---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

<ipython-input-7-df434c06b06e> in <module>()
      7                 'で年齢は' + str(age1) + 'です。これは毎回表示されます。')
      8 
----> 9 box4 = keisan()

TypeError: __init__() missing 2 required positional arguments: 'name1' and 'age1'

なにも入れないとprintが実行できないからエラーになる。
"""

# 一人目の名前はMikeで年齢は19です。これは毎回表示されます。

"""
表示処理しておわり。

このままでは入力したものが取り出せない。


box4.name1

---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

<ipython-input-9-53236fb457a0> in <module>()
----> 1 box4.name1

AttributeError: 'keisan' object has no attribute 'name1'

エラーになる
保存したければ引数をつくっておく
"""

class Keisan:
	num1 = 1
	num2 = 2

	def __init__(self, name1, age1):
		self.name1 = name1
		self.age1 = age1
		print('一人目の名前は' + name1 + 'で年齢は' + str(age1) + 
			'です。これは毎回表示されます。')

box5 = Keisan('Rachel', 22)
print(box5.name1)    # Rachel とりだせた。
# 一人目の名前はRachelで年齢は22です。これは毎回表示されます。


"""
引数は無いけど決まった処理を行いたい時
"""

class Keisan:
	num1 = 1
	num2 = 2
	def __init__(self, val1):
		self.val1 = val1

	def plus10(self):
		self.val1 += 10

box6 = Keisan(val1 = 15)
print(box6.val1)    # 15

"""
クラス内のplus10メソッドを使う
"""

box6.plus10()
print(box6.val1)    # 25


"""
クラス内のオブジェクトを変更するメソッド

引数はselfでなくclsにする
"""

class Keisan:
	num2 = 2
	def __init__(self, val1):
		self.val1 = val1

	def plus10(self):
		self.val1 += 10

	def plus5(cls):
		cls.num2 += 5

box7 = Keisan(val1 = 22)
print(box7.num2)    # 2

"""
classのnum2を変更するメソッドのplus5を実行する
"""

box7.plus5()
print(box7.num2)    # 7

"""
クラス内のnum2が変更できた


お作法　変えてほしくない

classを設計して他人にコードを公開する時、設計上変更してほしくない部分は「_」記号を付ける。
"""

class Keisan:

	def __init__(self, val1, val2):
		self._val1 = val1    # 変えてほしくない
		self.val2 = val2    # 変えてもいい

box9 = Keisan(10, 20)
print(box9._val1)    # 10
print(box9.val2)    # 20

box9._val1 = 30
print(box9._val1)    # 30

"""
変えられちゃうんですけどね


もうちょっと変えてほしくない気持ちを強くする
"""

class Keisan:

	def __init__(self, val1, val2):
		self.__val1 = val1    # 変えてほしくない気持ちを強く
		self.val2 = val2    # 変えてもいい

box10 = Keisan(10, 20)

"""
box10.__val1

---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

<ipython-input-15-68ebfca72338> in <module>()
      6 
      7 box10 = keisan(10,20)
----> 8 box10.__val1

AttributeError: 'keisan' object has no attribute '__val1'

エラーになる
確認できなくなった。


どうしても触りたいときは「_クラス名」を間に挟む

クラス名の確認
"""

print(type(box10))    # <class '__main__.Keisan'>

print(box10._Keisan__val1)     # 10

"""
確認できた。
_が一つよりも隠せた。


名前空間がよくわからないけど

名前空間とは名前からオブジェクトへの対応付けに関係する概念
モジュール1番(機能のまとまり。関数のまとまりをイメージ)の中にある関数1がある。
おなじ名前の関数は、別のモジュールの中で定義されていたらなば、同じ名前でも別物として扱える
このような関数は異なった名前空間の関数の名前であり、関係は持たない
らしいので確かめる
"""

class cs1:
	def __init__(self, val1):
		self.val1 = val1

	def cal1(self, val2):
		self.kekka = self.val1 * val2

class cs2:
	def __init__(self, val1):
		self.val1 = val1

	def cal1(self, val2):
		self.kekka = self.val1 + val2

class1 = cs1(10)
class1.cal1(15)
print(class1.kekka)    # 150

class2 = cs2(10)
class2.cal1(15)
print(class2.kekka)    # 25

"""
同じ関数の名前でも別のclassのメソッドであれば別処理が行われる。
"""
