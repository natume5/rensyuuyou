#!/usr/bin/python
# -*- coding: UTF-8 -*-


import random
import math

# スイカ割りゲームを作ってみよう

"""
ここまでに学んだPythonの知識を活用して、初心者でも作れる簡単な「スイカ割りゲーム」を作ってみましょう。

「スイカ割りゲーム」は、どこかに隠されているスイカを探して、プレイヤーがゲーム盤上を歩き回るゲームです。
スイカを探すヒントとして、プレーヤーとスイカの間の距離が与えられます。

この「スイカ割りゲーム」は、簡単で短いプログラムですが、
Pythonで本格的なプログラムを作るために必要な要素をたくさん含んでいます。
"""

# スイカ割りゲームを開発する手順

"""
ここでは、次のような手順でスイカ割りゲームを設計し、開発していきます。

    「スイカ割りゲーム」はどんなゲームなのか考える
    ゲームを構成する手続きを考える
    手続きごとに、Pythonのプログラムを開発する
"""

# 「スイカ割りゲーム」はどんなゲームなのか考える
"""
ちゃんと動作するプログラムを開発するには、当然ながら「何を 作るのか？」
ということをしっかり理解する必要があります。まず、そのプログラムの目的や使い方をしっかり考えてみましょう。

前述のように、「スイカ割りゲーム」は、どこかに隠されているスイカを探して、
プレイヤーがゲーム盤上を歩き回るゲームです。スイカを探すヒントとして、プレーヤーとスイカの間の距離が与えられます。

ゲームは、次の図のようにマス目が入った将棋盤のようなゲーム版で行われます

左上のマスの座標は(0, 0)で、x座標は左から右に向かって(1, 0)、(2, 0)、…… と増えていき、
y座標は上から下に向かって (0, 1)、(0, 2)、…… と増えていくようにしましょう。

このゲームがどのように進められるのか、もう少し具体的に考えてみましょう。

コンピュータープログラムではなく、本物の目隠しをしたプレーヤーとスイカでゲームを行うとしたら、こんなルールになるでしょうか。

    スイカとプレイヤーは、ゲーム盤上のランダムなマスに配置されます。
    スイカを探すヒントとして、スイカからプレーヤーまでの距離を報告します。
    プレイヤーは、北・南・東・西にそれぞれ一マスずつ移動できます。
    スイカとプレイヤーが同じマスに入るまで、2. と 3. を繰り返します。

実際にゲームとして遊べるようになるまで、しっかりとイメージを膨らませてみてください。
"""

# ゲームを構成する手続きを考える
"""
前節では、スイカ割りゲームでは「何を」開発するのか、ということを検討しました。

次に、このゲームを、「どのように」プログラムとして実現し、動作するのか、という具体的な手順を考えてみましょう。

さきほどまとめたゲーム内容をもう１段階細かく検討し、どんな処理が必要になるのかをよく考えて、
実際にPythonで記述する準備をします。

こういった、プログラムで実際に実行する手順や処理のことを、よく「手続き」といいます。

このゲームの「手続き」を、詳しく考えてみましょう。

    スイカとプレイヤーの初期位置を決めます。
    スイカとプレイヤーの位置がおなじになるまで、以下の処理を繰り返します。
        スイカからプレイヤーまでの距離を出力します。
        キーボードから文字をうけとります。
        受け取った文字がnなら北、sなら南、eなら東、wなら西に一マス移動します。
    ゲーム終了のメッセージを表示します。

こんな感じでいけそうです。こういったプログラムの構成は、最初はうまくできないかもしれませんが、
いろいろなプログラムを読んだり書いたりしているうちに、できるようになってきます。

こういった、プログラムの構造を設計するのは、プログラミング言語の勉強だけではなかなか上達しません。
簡単なものでも、アプリケーションを自分で考えて開発してみるのが大事です。

ここからは、それぞれの手続をさらにもう１段階細かく検討してみましょう。
"""

# スイカとプレイヤーの初期位置
"""
スイカとプレイヤーの位置は、毎回乱数で違った場所になるようにします。
あんまり距離が離れすぎてもゲームになりませんから、
ここでは、スイカとプレイヤーのx座標とy座標は 0 から ４ までの範囲に収まるようにしましょう。

乱数を生成する

Pythonでは、乱数を生成するときには random モジュールを インポート します。
スイカとプレイヤーの座標は ０ から 4 までの整数ですので、ここではrandomモジュールのrandrange関数を利用します。

インポートしたモジュールの関数は、モジュール名.関数名() の形式で呼び出します。
忘れていたら、モジュールとimport を読んで復習してください。

randrange() は、

random.randrange(開始値, 終了値)

の形式で指定すると、開始値以上かつ終了値未満(開始値 ≦ 乱数 < 終了値) となる乱数を生成します。

次の例は、0以上5未満の乱数を３回生成しています。
"""
# import random

print(random.randrange(0, 5))
print(random.randrange(0, 5))
print(random.randrange(0, 5))


# スイカとプレイヤーの位置を設定する
"""
random.randrange()関数 を使って、スイカとプレイヤーの位置を決定するコードを書いてみましょう。

スイカの位置のx座標とy座標は変数 suika_x と suika_yに、
プレイヤーの位置のx座標とy座標は変数 player_x と player_y に代入することにします。

スイカとプレイヤーの位置を決める処理は、次のようになります。

"""

"""
# スイカの位置を決める
suika_x = random.randrange(0, 5)  # スイカのx座標
suika_y = random.randrange(0, 5)  # スイカのy座標

# プレイヤーの位置を決める
player_x = random.randrange(0, 5)  # プレイヤーのx座標
player_y = random.randrange(0, 5)  # プレイヤーのy座標
"""
"""
これで、スイカとプレイヤーの位置が決まりました。

どちらもランダムに位置を決定しているだけですので、
スイカとプレイヤーの初期位置は25分の1の確率では同じところになリます。
この場合、ゲームは開始すると同時に終了してしまいますが、とりあえずここでは気にしないでおきましょう
"""

# ゲームのループ処理
"""
次に、プレイヤーとスイカの位置が一致するまで繰り返すループ処理を考えましょう。

このループは、スイカとプレイヤーの位置が異なるあいだ繰り返す while文によるループ として記述できます。

while スイカとプレイヤーの位置が異なっている:
    ...

スイカとプレイヤーの位置が異なっている という条件は、
スイカのx座標とプレイヤーのx座標が違う

という条件と、
スイカのy座標とプレイヤーのy座標が違う

という条件の、どちらか一方でも 真 ならば、スイカとプレイヤーの位置が異なっている と言えます。

スイカとプレイヤーのx座標が違う という条件は、比較演算子 の != を使って、次のようにかけます。

suika_x != player_x

同様に、y座標が違う という条件は、

suika_y != player_y

となります。

さきほどの while ループ

while スイカとプレイヤーの位置が異なっている:
    ...

の スイカとプレイヤーの位置が異なっている という条件は、この２つの条件のうち、
どちらか一方でも 真 となった場合ですから、論理演算子の or 演算子 を使って

while (suika_x != player_x) or (suika_y != player_y):
    ...

と書けます。while文には、行末の : が必要ですから忘れないようにしてください。

スイカのx座標 suika_x とプレイヤーのx座標 player_x が等しければ、

suika_x != player_x

という比較式の値は False となります。

また、スイカのy座標 suika_y とプレイヤーのy座標 player_y が等しければ、

suika_y != player_y

も False となります。

したがって、x座標とy座標の両方でプレイヤーとスイカの座標が等しい場合は、

(suika_x != player_x) or (suika_y != player_y)

という式は

False or False

となり、or演算子の結果は False となり、while を継続する条件が成立しないため、ループは終了します。
"""

# スイカからプレイヤーまでの距離を求める
"""
while ループの中では、まず、スイカからプレイヤーまでの距離を求めて表示します。

スイカからプレイヤーまでの距離は、次の式で求められます。
$$ 距離 = \sqrt{(player\_x-suika\_x)^2 + (player\_y-suika\_y)^2} $$

Pythonでは、mathモジュールのsqrt()関数 で平方根を計算できます。
次のように mathモジュールを import して、距離を計算してみましょう。

import math
diff_x = player_x - suika_x
diff_y = player_y - suika_y
distance = math.sqrt(diff_x**2 + diff_y**2)

この処理は、２点間の距離を求める 関数 として定義しましょう。

import math

def calc_distance(x1, y1, x2, y2):
    diff_x = x1 - x2
    diff_y = y1 - y2

    return math.sqrt(diff_x**2 + diff_y**2)

このように関数として calc_distance() を定義しておけば、スイカとプレイヤーの距離は次のように求められます。

distance = calc_distance(player_x, player_y, suika_x, suika_y)
"""
"""
def calc_distance(x1, y1, x2, y2):
    diff_x = x1 - x2
    diff_y = y1 - y2

    return math.sqrt(diff_x**2 + diff_y**2)


distance = calc_distance(player_x, player_y, suika_x, suika_y)
"""
# プレイヤーの移動処理

"""
while ループ中では、スイカとプレイヤーの距離を表示してから、
input()関数を使ってユーザからのキー入力を読み取り、キーに従ってプレイヤーの位置を移動します。
ユーザが入力した文字が nなら北、sなら南、eなら東、wなら西に一マス移動します。
それ以外の文字なら、何もしません。

プレイヤーを北に移動する場合は、プレイヤーのy座標(player_y)を -1 して、
ボードの上方に移動します。逆に、南に移動する場合はy座標を +1 して下方に移動します。

同様に、プレイヤーを西に移動する場合にはプレイヤーのx座標(player_x)を -1 し、
東に移動する場合には +1 します。

この処理をまとめると、次のようになります。
"""
"""
c = input("n:北に移動 s:南に移動 e:東に移動 w:西に移動")
if c == "n":
    player_y = player_y - 1
elif c == "s":
    player_y = player_y + 1
elif c == "w":
    player_x = player_x - 1
elif c == "e":
    player_x = player_x + 1
"""
"""
input()で入力された文字列は変数 c に代入されます。 
まず、if文 の条件として c == "n" という比較演算を指定して、
c が 文字列 "n" と等しいかどうかをチェックしています。
c の値が "n" の場合は比較演算子 == の結果は 真 となり、プレイヤーを北に移動しています。

c == "n" が 偽 の場合は、次にelif節 に 指定した c == "s" という比較を行い、
c が 文字列 "n" と等しいかどうかをチェックしています。この演算子が 真 であればプレイヤーを南に移動します。

同様に、c == "s" が 偽 の場合には、次の elif節の c == "w" の真偽を判定します。
これも偽 なら最後に c == "e" を判定して、入力に応じたプレイヤーの位置を移動します。
"""


def calc_distance(x1, y1, x2, y2):
	# 2点間の距離を求める
    diff_x = x1 - x2
    diff_y = y1 - y2

    return math.sqrt(diff_x**2 + diff_y**2)


# スイカの位置を決める
suika_x = random.randrange(0, 5)  # スイカのx座標
suika_y = random.randrange(0, 5)  # スイカのy座標

# プレイヤーの位置を決める
player_x = random.randrange(0, 5)  # プレイヤーのx座標
player_y = random.randrange(0, 5)  # プレイヤーのy座標

# スイカとプレイヤーの位置が異なる間、処理を繰り返す
while (suika_x != player_x) or (suika_y != player_y):

    # スイカとプレイヤーの距離を表示
	distance = calc_distance(player_x, player_y, suika_x, suika_y)
	print("スイカへの距離:", distance)

	# キー入力に応じて、プレイヤーを移動する
	c = input("n:北に移動 s:南に移動 e:東に移動 w:西に移動")
	if c == "n":
		player_y = player_y - 1
	elif c == "s":
		player_y = player_y + 1
	elif c == "w":
		player_x = player_x - 1
	elif c == "e":
		player_x = player_x + 1

print("スイカを割りました！")

"""
一般的なPythonの慣習で、import 文はプログラムの先頭に記述します。
また、calc_distance() などの関数は、import 文に続けて記述します。

これで「スイカ割りゲーム」の完成です。
"""

# まとめ
"""
この例題は短いプログラムですが、本格的なプログラムを書くために必要な要素がたくさん含まれています。

ここでは、プログラムをゼロから開発する時の考え方を、すこし細かく説明してみました。
こんなに短いプログラムでも、開発手順を文章で説明するとけっこうな長さになってしまいます。

最初のうちはちょっと大変かもしれませんが、このぐらいのプログラムをスラスラ書けるようになると、
初歩的なプログラミングの考え方をマスターしたと言えるでしょう。

これが、自分自身のアイデアをPythonプログラミングで実現するための第一歩になります。
時間がかかっても、しっかり理解しましょう。
"""


# リファクタリング - マジックナンバーを避ける
"""
スイカ割りゲーム はとりあえず動き、ゲームを実行できるようになりました。

しかし、プログラムの書き方としては今一つな点があります。
本格的な改善はこの講座の範囲を超えますが、いくつか簡単なポイントを改善してみましょう。

このように、プログラムの機能はそのままで、書き方を改善することを リファクタリング といいます。
"""

# マジックナンバーを避ける
"""
このプログラムでは、スイカとプレイヤーの初期位置は 5×5 の範囲内としています。この範囲は、generate_position(5) のように、引数として指定しています。

suika_pos = generate_position(5)  # スイカの位置
player_pos = generate_position(5) # プレイヤーの位置

しかし、あとからこのプログラムを読むとき、いきなり 「5」という数字だけが書いてあった場合、
この数値がどんな意味の値なのか、覚えていられるでしょうか？

運良く覚えていられるかもしれないし、忘れているかもしれませんが、忘れていても問題ないように、
ちゃんと意味がわかるようにしておきましょう。こういう場合、直接 5 という数字を書くのではなく、
わかりやすい名前をつけた変数に代入してして使用するようにします。

この場合だと、5 はこのゲームのボードのサイズですから、BOARD_SIZE という名前にしましょう。
Pythonの慣例で、このような定数値の変数名は小文字のboard_size ではなく、
BOARD_SIZE のようにすべて大文字にします。

BOARD_SIZE = 5  # ボードの初期サイズ

suika_pos = generate_position(BOARD_SIZE)  # スイカの位置
player_pos = generate_position(BOARD_SIZE) # プレイヤーの位置

こうしておけば、BOARD_SIZE という名前を手がかりに、どんな意味を持つ値なのか、
きっと思い出すことができるでしょう。
また、サイズを変更する場合は BOARD_SIZE の値を修正するだけで済むようになります。

この 5 のように、プログラム中にいきなり出てくる意味のわからない数字は、一般に マジックナンバー といいます。
基本的には、マジックナンバーは、値を直接書くのではなく、その値の意味がわかるように、
常に変数に代入してから利用するようにします。

マジックナンバーを変数に代入せず、あっちこっちで使ってしまうと、
あとでその値の意味がわからなくなってしまったり、値を変更するときに修正漏れが発生したりします。

ということで、5 という数字を直接使うのはやめて、BOARD_SIZE に代入して使用するように変更を加えると、
次のようになります。
"""


BOARD_SIZE = 5    # ボードの初期サイズ

def calc_distance(x1, y1, x2, y2):
    # 2点間の距離を求める
    diff_x = x1 - x2
    diff_y = y1 - y2

    return math.sqrt(diff_x ** 2 + diff_y ** 2)


suika_x = random.randrange(0, BOARD_SIZE)    # スイカのx座標 ← この行を修正
suika_y = random.randrange(0, BOARD_SIZE)    # スイカのy座標 ← この行を修正

player_x = random.randrange(0, BOARD_SIZE)    # プレイヤーのx座標 ← この行を修正
player_y = random.randrange(0, BOARD_SIZE)    # プレイヤーのy座標 ← この行を修正

# スイカとプレイヤーの位置が異なる間、処理を繰り返す
while (suika_x != player_x) or (suika_y != player_y):

    # スイカとプレイヤーの距離を表示する
    distance = calc_distance(player_x, player_y, suika_x, suika_y)
    print("スイカへの距離:", distance)

    # キー入力に応じて、プレイヤーを移動する
    c = input("n:北に移動 s:南に移動 e:東に移動 w:西に移動")
    if c == "n":
        player_y = player_y - 1
    elif c == "s":
        player_y = player_y + 1
    elif c == "w":
        player_x = player_x - 1
    elif c == "e":
        player_x = player_x + 1

print("スイカを割りました！")


# 適切なデータ型を使う
"""
元のソースコードでは、スイカとプレイヤーの位置を、x座標とy座標それぞれ別々の変数として保持しています。

suika_x = random.randrange(0, BOARD_SIZE)  # スイカのx座標
suika_y = random.randrange(0, BOARD_SIZE)  # スイカのy座標

player_x = random.randrange(0, BOARD_SIZE) # プレイヤーのx座標
player_y = random.randrange(0, BOARD_SIZE) # プレイヤーのy座標

しかし、スイカやプレイヤーの座標は本来一つの情報ですので、x座標とy座標で2つの変数に分ける意味はありません。
こういった場合、

    (x座標, y座標)

という形式の、2つの整数からなる タプル にするように、リファクタリング するのが良いでしょう。

ここでは、タプルを利用する練習も兼ねて、位置情報をタプルに置き換えていきましょう。
"""

# 座標の生成方法を変更
"""
現在、スイカとプレイヤーの座標は、x座標とy座標に分けて、四つの変数に代入されています。
これを、suika_pos、player_pos という名前の、タプルを参照する変数に変更しましょう


# スイカの位置のタプル
suika_pos = (random.randrange(0, BOARD_SIZE), random.randrange(0, BOARD_SIZE))

# プレイヤーの位置のタプル
player_pos = (random.randrange(0, BOARD_SIZE), random.randrange(0, BOARD_SIZE))



変数名 suika_pos と player_pos の pos は、英語の 位置(position) から取っています。

生成した値を表示してみましょう。

print("スイカの位置は", suika_pos)
print("プレイヤーの位置は". player_pos)

データの形式が決まりましたので、プログラム全体で、スイカとプレイヤーの座標データとして、
このタプルを使うように書き換えていきます。
"""


# 距離計算関数を修正
"""
二点間の距離を計算する関数 calc_distance() は、
引数 として２つの位置のx座標とy座標を受け取り、距離を計算して返します。

def calc_distance(x1, y1, x2, y2):
    # 2点間の距離を求める
    diff_x = x1 - x2
    diff_y = y1 - y2

    return math.sqrt(diff_x ** 2 + diff_y ** 2)

この関数を呼び出すときは、四つの数字を指定します。

x1 = 10
y1 = 10
x2 = 20
y2 = 20

calc_distance(x1, y1, x2, y2)    # 座標(10, 10)から座標(20, 20)までの距離を計算する



この関数の 引数 を、別々にx座標とy座標を指定するのではなく、座標をタプルで指定するように変更しましょう。

def calc_distance(pos1, pos2):    # この行を修正
    # 2点間の距離を求める
    diff_x = pos1[0] - pos2[0]    # この行を修正
    diff_y = pos1[1] - pos2[1]    # この行を修正

    return math.sqrt(diff_x ** 2 + diff_y ** 2)

呼び出すときは、次のようにタプルを指定します。

pos1 = (10, 10)
pos2 = (20, 20)

calc_distance(pos1, pos2)    # 座標(10, 10)から座標(20, 20)迄の距離を計算

データを２つのタプルにまとめることで、
２つの位置のx座標とy座標の数値のまとまりが明確になり、シンプルになっているのがわかると思います。
"""


# while文を修正
"""
ゲームの中心となるwhile 文の、ループ継続条件は次のようになっています。

# スイカとプレイヤーの位置が異なる間、処理を繰り返す
while (suika_x != player_x) or (suika_y != player_y):
    ...

修正前の書き方では、スイカとプレイヤーの位置を、x座標とy座標で別々に比較しています。

修正後は、座標をタプルに変更していますから、次のように、２つの値を一度に比較できます。

# 修正後
while suika_pos != player_pos:
    ...

x座標とy座標を別々に比較するのに比べて、すっきりとしていますね。
２つのタプルを == を比較する方法については、タプルの比較演算子 を復習しておいてください。
"""


# プレイヤー移動処理を変更
"""
元の処理では、キー入力に応じてプレイヤーを移動する処理は次のようになっています。

# キー入力に応じて、プレイヤーを移動する
c = input("n:北に移動 s:南に移動 e:東に移動 w:西に移動")
if c == "n":
    player_y = player_y - 1
elif c == "s":
    player_y = player_y + 1
elif c == "w":
    player_x = player_x - 1
elif c == "e":
    player_x = player_x + 1

タプルオブジェクトの操作 で説明したように、タプルは、リスト と違って要素を別々に変更できません。

プレイヤーの位置を player_pos から取り出して、座標を更新してから新しいタプルを作るように修正します。

# 修正後

# キー入力に応じて、プレイヤーを移動する
c = input("n:北に移動 s:南に移動 e:東に移動 w:西に移動")

current_x, current_y = player_pos

if c == "n":
    current_y = current_y - 1
elif c == "s":
    current_y = current_y + 1
elif c == "w":
    current_x = current_x - 1
elif c == "e":
    current_x = current_x + 1

player_pos = (current_x, current_y)

"""


# タプルのアンパック
"""
この処理では、次のように変数 player_pos からx座標とy座標の値を取り出しています。

current_x, current_y = player_pos

これは、コレクションのアンパック で紹介した、タプルをアンパックした代入文です。
player_pos の最初の要素と次の要素を、それぞれ変数 current_x と current_y に代入しています。
"""


# まとめると
"""
以上で、スイカとプレイヤーの座標をタプルとして保持するための修正が終わりました。
最終的なプログラムは次のようになります。
"""

BOARD_SIZE = 5    # ボードの初期サイズ

def calc_distance(pos1, pos2):    # この行を修正
    # 2点間の距離を求める
    diff_x = pos1[0] - pos2[0]    # この行を修正
    diff_y = pos1[1] - pos2[1]    # この行を修正

    return math.sqrt(diff_x ** 2 + diff_y ** 2)


suika_pos = (random.randrange(0, 5), random.randrange(0, 5))    # スイカの位置
player_pos = (random.randrange(0, 5), random.randrange(0, 5))    # プレイヤーの位置

# スイカとプレイヤーの位置が異なる間、処理を繰り返す
while (suika_pos != player_pos):

    # スイカとプレイヤーの距離を表示
    distance = calc_distance(suika_pos, player_pos)
    print("スイカへの距離:", distance)

    # キー入力に応じて、プレイヤーを移動
    c = input("n:北に移動 s:南に移動 e:東に移動 w:西に移動")
    current_x, current_y = player_pos

    if c == "n":
        current_y = current_y - 1
    elif c == "s":
        current_y = current_y + 1
    elif c == "w":
        current_x = current_x - 1
    elif c == "e":
        current_x = current_x + 1

    player_pos = (current_x, current_y)

print("スイカを割りました！")
