#!/usr/bin/python
# -*- coding: UTF-8 -*-


# タプル
"""
世の中のデータにはさまざまな種類があり、中には複数のデータから構成されているものがあります。例えば、

    東京都の人形町駅の位置は、緯度と経度で表すと、緯度 35.686321、 経度 139.782211 
    という2つの数値の組み合わせから構成されます。
    日本での氏名は、名字と名前という2つの文字列の組み合わせから構成されます。
    日本の年号は、昭和・平成などの元号と、20 や 30 などの数値の組み合わせから構成されます。
    色は、赤・緑・青の三原色を表す3つの数値の組み合わせで表現できます。
    例えば、黄色は赤 255、緑 255、 青 0 という組み合わせです。

このように、一つの情報が、複数の情報の組み合わせから構成されている、というのは非常に一般的です。
"""

# タプル
"""
Pythonでは、このような複数のデータの組み合わせから構成されているデータを表現する場合、
タプル という種類のオブジェクトを利用します。

タプル(tuple)というのはあんまり聞き慣れない言葉ですが、組 などとも呼ばれ、
複数の要素が決まった順番にならんだ値を指します。
"""

# タプルの書き方
"""
タプルオブジェクトは、複数の値をカンマ , で区切って記述します。
例えば、上記の人形町駅の位置は、緯度と経度をタプルであらわすと次のようになります。
"""
ningyocho = (35.686321, 139.782211)
print(ningyocho)

kotosi = ('令和', 4)
print(kotosi)

# タプルオブジェクトの要素を参照する
"""
タプルオブジェクトに登録したオブジェクトは、リスト と同じように 要素の順番 を指定して参照できます。

タプルオブジェクト[要素の順番]

要素の順番 として指定する数値のことを、リストオブジェクトと同じように インデックス(添字) と呼びます。

人形町駅の緯度と経度のタプルは

ningyocho = (35.686321, 139.782211)

でした。このタプルから、緯度と経度を取り出してみましょう。ningyocho は (緯度, 経度) 
という形式のタプルオブジェクトですから、最初の要素が緯度、次の要素が経度です。

最初の要素はインデックスに 0 を、次の要素はインデックスとして 1 を指定して参照できますから、
緯度と経度は次のようにして取り出せます。
"""
ningyocho = (35.686321, 139.782211)

ido = ningyocho[0]    # 緯度は先頭の要素
keido = ningyocho[1]    # 経度は次の要素

print("人形町の緯度は", ido, "経度は", keido, "です")

# タプルの比較演算子
"""
タプルは、数値や文字列と同じように、比較演算子 を使って他のタプルと値を比較できます。

== 演算子でタプル同士を比較すると、同じ値のタプルならTrue を返します。
"""
value1 = (1, 2, 3)
value2 = (1, 2, 3)

print(value1 == value2)    # 同じ値なのでTrueとなる


value1 = (1, 2, 3)
value2 = (2, 3, 4)

print(value1 == value2)    # 異なる値なのでFalseとなる


value1 = (1, 2, 3)
value2 = (1, 2, 3)
value3 = (2, 3, 4)

print(value1 != value2)    # 同じ値なのでFalseとなる
print(value1 != value3)    # 異なる値なのでTrueとなる


value2 = (1, 2, 3)
value3 = (1, 2, 4)

print(value1 < value2)    # value1 < value2なのでTrueとなる
"""
タプル同士の値の比較は、先頭の要素から順番に同じインデックス同士の値を比較して、
先に小さい値となったタプルが小さい値となります。

例えば、上記のように (1, 2, 3) と (1, 2, 4) を比較した場合、

    最初の要素の 1 と 1 を比較する。同じ値なので、次の値をチェックする。
    ２番めの要素の 2 と 2 を比較する。同じ値なので、次の値をチェックする。
    3番目の要素の 3 と 4 を比較する。 3 < 4 なので、(1, 2, 3) は (1, 2, 4) よりも小さい。

のように比較を行います。

比較するタプル同士の長さが異なる場合、短いタプルの要素と長いタプルの要素を比較してすべて等しければ、
短い要素のほうが小さい値となります。

たとえば、長さが 3 のタプル (1, 2, 3) と、長さが 4 のタプル (1, 2, 3, 4)は、
長さ 3 のタプルの要素はすべて長さ 4 のタプルと一致しますので、長さが短い (1, 2, 3) 
が小さい値のタプルとなります。
"""
value1 = (1, 2, 3)
value2 = (1, 2, 3, 4)

print(value1 < value2)


# タプルオブジェクトの操作
"""
リストオブジェクトの場合は、要素を参照する以外に、追加や削除、変更などの操作 を行えます。
次の例は、数値の 1, 2, 3 からなるリストを作成したあと、最初の要素を文字列の a に書き換えています。
"""
sample = [1, 2, 3]    # リストオブジェクトの作成
sample[0] = "a"    # 要素の作成
print(sample)
"""
しかし、タプルオブジェクトの場合、リストオブジェクトのように要素を変更することはできません。
タプルオブジェクトの要素を変更する場合は、リストオブジェクトのように要素を変更するのではなく、
あたらしくタプルオブジェクト全体を作り直す必要があります。

たとえば、color という変数に、色の情報を三原色(赤・緑・青) のタプルとして黄色 (255, 255, 0) 
が設定されているとします。
"""
color = (255, 255, 0)    # 黄色
print(color)
"""
color の色を、黄色 (255, 255, 0) から赤 (255, 0, 0) に変更したい場合でも、
リストオブジェクトのように値を更新することはできません。次のようなエラーになります。

color[1] = 0  # 緑色を 0 に変更

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-45-8f192bf0a20a> in <module>
----> 1 color[1] = 0  # 緑色を 0 に変更

TypeError: 'tuple' object does not support item assignment

color の要素の値を変更する場合は、タプルの要素を変更するのではなく、新しくタプルを作り、
変数 color に代入して更新します。
"""
color = (255, 0, 0)    # 赤
print(color)


# タプルとリスト
"""
タプルとリストはとてもよく似ています。

どちらも他のデータを格納できるコンテナオブジェクトで、格納した要素は数値をインデックスとして参照できます。
リストにはデータを追加したり削除したりできますが、タプルは変更できません。タプルとリストの見た目もよく似ています。

list_values = [1, 2, 3]  # リスト
tuple_values = (1, 2, 3) # タプル

リストとタプルはどのように使い分ければよいのでしょうか？

前述のように、タプルは

    複数のデータの組み合わせから構成されているデータ

のためのオブジェクトです。

次の例は、学校である生徒の定期テストの結果をデータとして記述しています。

sugaku = 50  # 数学の点数
kokugo = 60  # 国語の点数
eigo = 70  # 英語の点数

exam_scores = (sugaku, kokugo, eigo)

exam_scores は、ある生徒の成績を

    (数学の点数, 国語の点数, 英語の点数)

という決まったルールで記述した、固定的な形式のデータです。

このように、複数の要素から構成される独立したデータ をあらわすときは、タプルを使用します。

もう一つの例として、たくさんの生徒のテストの点数を、教科ごとにまとめたデータを考えてみましょう。

sugaku_scores = [82, 12, 12, 94, 86, 5]
kokugo_scores = [99, 64, 99, 39, 56, 1, 77, 57, 82, 75, 5, 74, 3]
eigo_scores = [16, 81, 82, 47, 80, 48, 10, 72, 81, 7]

ここで定義した変数 sugaku_scores、kokugo_scores、eigo_scores は、
それぞれ数学、国語、英語の、全受験者の点数をまとめたリストです。
それぞれの教科では受験者数が違うため、要素数も全て異なっています。

このように、固定的な形式をもつ独立したデータではなく、不定個数の独立したデータをたくさん集約してまとめておきたい、
という用途には、リストが適しています。

もちろん、タプルを使わず、常にリストを使用することもできますが、その場合次のようなデメリットが考えられます。

    exam_scores のようにタプルで作られたデータは、あとからプログラムを参照する人に
     「これは複数の値から構成されるデータだ」 という情報を伝え、プログラムの意図を理解する助けになります。
     リストにしてしまうと、間違った意図を伝えることになります。

    タプルは個別のデータをあらわすオブジェクトなので、
    非常にたくさんのオブジェクトが使用されても効率的に処理できるようになっています。

    テストの例で考えると、受験者が100万人いた場合は exam_scores 
    のようなデータが100万個作られることになります。
    タプルの場合には100万件のデータを作っても最小限の負荷で抑えられますが、
    リストで同じデータを100万個作ると、タプルと比べて大きな負荷がかかります。

これまで、 整数や実数、 文字列 などの データ型 を紹介してきました。
また、複数のデータを順番に登録する リスト と タプル や、
データとデータの対応関係を登録する 辞書 も紹介しました。

いろいろなデータ型が出てきて、困ってしまいますね。
実のところ、これはまだまだ序の口で、これからももっとたくさん出てきます。

そんなにたくさんの種類があると、それぞれ全部の使い方をいちいち覚えておくのは大変です。
そこで、Pythonなど、多くのプログラミング言語では、似たような種類のデータ型をグループとしてまとめ、
それぞれのグループは同じような方法で使えるようになっています。

これなら、全部の種類のデータ型について、いちいち細かいところまで覚えておかなくても、
それぞれのグループについて勉強しておくだけでだいたい使えるようになります。

ここでは、そういったグループの中から、コレクション を紹介します。
"""


# コレクション
"""
数値オブジェクトは、物質の重さや長さなど、いろいろなデータの値を直接あらわすオブジェクトです。
一方、 リストや辞書は、直接的なデータではなく、いろいろなデータを登録して、
集約しておくために使われるオブジェクトです。

リストやタプル、辞書のように、他のオブジェクトを集約することを目的とした種類のオブジェクトのことを、

    コレクション (Collection)

と呼びます。

また、"ABC" のような 文字列 も、文字 A、B、C を集約したオブジェクトですので、コレクション の仲間です。
"""

# コレクションの操作
"""
コレクションに属するオブジェクトは、どれも同じように使える、共通の処理が用意されています。
以下で、その一部を紹介します。
コレクションの要素数

コレクションに登録されている要素の数は、len() 関数で調べられます。

辞書オブジェクトの要素数は、次のように求められます
"""
dict_obj = {"dog": "犬", "cat": "猫"}
print("辞書の要素数は:", len(dict_obj))


"""
タプルオブジェクトの要素数は、次のように求められます
"""
tuple_obj = (1, 2, 3)
print("タプルの要素数は:", len(tuple_obj))


"""
リストオブジェクトの要素数は、次のように求められます。
"""
list_obj = [1, 2, 3, 4]
print("リストの要素数は:", len(list_obj))


"""
文字列オブジェクトの文字数は、次のように求められます。
"""
str_obj = "12345"
print("文字列の長さは:", len(str_obj))

"""
辞書・タプル・リスト・文字列と、どの型のオブジェクトでも、コレクション であれば、
同じように len() 関数で要素の数を求められます。

len()関数については、while文を使ったリストのループ処理 でも紹介していますので参照してください。
"""


# コレクションの比較演算子
"""
コレクションは、比較演算子 の == 演算子や != 演算子で、値が等しいかどうかを判定できます。

== 演算子でコレクション同士を比較すると、同じ値のコレクションなら True を、異なっていれば False を返します。
"""
dict1 = {"dog": "犬", "cat": "猫"}
dict2 = {"dog": "犬", "cat": "猫"}

print("dict1とdict2は等しいか？", dict1 == dict2)


list1 = [1, 2, 3]
list2 = [1, 2, 4]

print("list1とlist2は等しいか？", list1 == list2)


dict1 = {"dog": "犬", "cat": "猫"}
dict2 = {"dog": "犬", "cat": "猫"}

print("dict1とdict2は異なる値か？", dict1 != dict2)


list1 = [1, 2, 3]
list2 = [1, 2, 4]

print("list1とlist2は異なる値か？", list1 != list2)


# in 演算子
"""
in 演算子を使うと、コレクションに値が登録されているかどうかを調べられます。

in 演算子は < や == のような 比較演算子 の一種で、

値 in コレクション

という式は、指定した値がコレクションに登録されていれば True を、登録されていなければ False を返します。

たとえば、リストオブジェクトに "book" という文字列が登録されているかどうか調べるには、次のように書きます。
"""
list_obj = ["pen", "book", "notebook"]
if "book" in list_obj:
    print("list_objにbookが登録されています。")


"""
"book" in list_obj という式は、
list_obj に "book" という文字列が登録されていれば True を、登録されていなければ False を返します。
"""
list_obj = ["pen", "book", "notebook"]

print("book" in list_obj)    # list_objに"book"が含まれているか → True
print("pencil" in list_obj)    # list_objに"pencil"が含まれているか → False


"""
タプルオブジェクトも、同様に in 演算子で要素の存在を確認できます。
"""
tuple_obj = [2, 3, 5, 7, 9]
print(5 in tuple_obj)    # tuple_objに5が含まれているか → True
print(11 in tuple_obj)    # tuple_objに11が含まれているか → False


# 辞書の in 演算子
"""
辞書オブジェクトの場合、in 演算子は指定した キー が 登録されているかどうかを調べます。

次の辞書 dict_obj は、以下のような要素を登録しています。

dict_obj = {"dog": "犬", "cat": "猫", "parrot": "オウム"}

キー(英単語)     値(日本語)
dog     犬
cat     猫
parrot  オウム

この辞書に cat という単語が登録されているか調べる場合は、in 演算子を使って次のように記述します。
"""
dict_obj = {"dog": "犬", "cat": "猫", "parrot": "オウム"}

if "cat" in dict_obj:
    print("catは", dict_obj["cat"], "です")


# 文字列の in 演算子
"""
文字列オブジェクトの場合も、in 演算子で中に文字が含まれているかどうかを確認できます。
"""
str_obj = "hello world"

print("w" in str_obj)    # "w"はstr_objに含まれているか → True
print("a" in str_obj)    # "a"はstr_objに含まれているか → False


"""
リストやタプルなど、他の種類のコンテナの場合、in 演算子に値として指定できるのは次のように一つだけです。

3 in [1,2,3,4,5]

しかし、文字列の場合には、1文字だけでなく、一連の文字を指定して検索できます。

例えば、文字列 abracadabra に cad という文字列が含まれているかどうか調べる場合は、次のように書けます。
"""
str_obj  = "abracadabra"

print("cad" in str_obj)    # "cad"はstr_objに含まれているか → True
print("rad" in str_obj)    # "rad"はstr_objに含まれているか → False


# for文
"""
コレクションは、for文によるループ で紹介した for 文に指定して、コレクションの要素ごとに、
for 文に記述した処理を実行できます。

次の処理は、リストオブジェクトの要素を、upper() メソッド を使って大文字に変換してから出力します
"""
list_obj = ["apple", "orange", "banana"]
for fruit_name in list_obj:
    upper_name = fruit_name.upper()
    print(upper_name)


"""
タプルの場合も、同様に for 文を使用できます。
"""
tuple_obj = ("apple", "orange", "banana")
for fruit_name in tuple_obj:
    upper_name = fruit_name.upper()
    print(upper_name)


"""
文字列を for 文に指定すると、文字列中の文字を一文字づつ取り出します。
"""
str_obj = "hello"
for letter in str_obj:
    upper_letter = letter.upper()
    print(upper_letter)
"""
この処理では、文字列 str_obj から文字を1文字ずつ取り出して変数 letter に代入し、
upper() メソッドを使って大文字に変換してから出力しています
"""


# 辞書とfor文
"""
辞書オブジェクトを for 文に指定すると、辞書のすべての キー を取り出して、for文に指定した処理を行います。
"""
dict_boj = {"dog": "犬", "cat": "猫", "parrot": "オウム"}

for english in dict_obj:
    japanese = dict_obj[english]
    print(english, "は", japanese, "です")
"""
この処理では、辞書 dict_obj に登録されている要素のキーを一つづつ取り出して、
変数 english に代入しています。変数 english の値は、
最初の一回目では dog、2回目は cat、3回目は parrot になります。

for ループ内にある次の処理

japanese = dict_obj[english]

は、取り出されたキー値(変数 english)を使って dict_obj からキー値に対応する値を取り出し、
変数 japanese に代入しています。

最後に、変数 english と japanese を使って、要素を print() しています。
"""
