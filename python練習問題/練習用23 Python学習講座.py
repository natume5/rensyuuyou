#!/usr/bin/python
# -*- coding: UTF-8 -*-


print("--- Python学習講座---")
print("--- Python入門　リスト内包表記---")


"""
リスト内包表記

リスト内包表記とはリストコンプリヘンションとも呼ばれ、
イテラブルな変数とループを利用して新たなリストを生成する構文のことです。
他の言語ではあまり見慣れない構文のためはじめは戸惑うかもしれませんが、
慣れると便利な上、使わない場合と比較して処理が速いというメリットがあります。

単純なリスト内包表記
[処理 for 変数 in リスト ]
if文と組み合わせたリスト内包表記
[処理 for 変数 in リスト if リスト要素に対する条件]

構文としては上記の通りなのですが、これだけだと何のことかわかりません。具体例で動作を確認してみましょう。
リスト内包表記の基本例

まずは単純な例からです。ある数値のリストが与えられていたとします。
そのリストの各要素を倍にしたリストを生成する場合について考えてみましょう。

リスト内包表記を使用しない場合、以下のようになります。
"""

data_list = [5, 3, 7, 4, 10, 9, 6]
new_list = []
for num in data_list:
	new_num = num * 2
	new_list.append(new_num)

print(new_list)    # [10, 6, 14, 8, 20, 18, 12]

"""
これと同じ処理をリスト内包表記で表してみましょう。以下のように書き換えることができます。
"""

data_list = [5, 3, 7, 4, 10, 9, 6]
new_list = [num * 2 for num in data_list]
print(new_list)     # [10, 6, 14, 8, 20, 18, 12]

"""
ずいぶんとスッキリ書くことができました。
変数numはdata_listをループ処理する際の変数で、
ここの順番が前後するため最初は理解することが難しく感じるのではないでしょうか。


if文と組み合わせる

また、if文と組み合わせて条件を加えて生成することが可能です。
少々複雑に感じるかもしれませんが、順を追って説明しますのでついてきてください。

ある数値のリストが与えられていたとします。このリストに対し、
「①各要素に対し、②偶数番目の要素を抜き出し、③2倍した結果」のリストを新たに作成することを考えてみます。
まずはリスト内包表記を使わない場合を考えてみます。
"""

data_list = [5, 3, 7, 4, 10, 9, 6]
new_list = []

for num in data_list:
	if num % 2 == 0:
		new_num = num * 2
		new_list.append(new_num)

print(new_list)    # [8, 20, 12]

"""
これと同じ処理をリスト内包表記で表すと、このように書き換えることができます。
"""

data_list = [5, 3, 7, 4, 10, 9, 6]
new_list = [num * 2 for num  in data_list if num % 2 == 0]    # [8, 20, 12]

"""
if文によって抽出時の条件が追加されたことが確認できます。


イテラブルなら何でも可

また、inの後に続くものはイテラブルなものであれば何でも可能です。
inの後ろに辞書を使ったサンプルを見てみましょう。
以下のサンプルでは、辞書のキーに対して前後に装飾文字列をつけてみます。
"""

data_dict = {"A": "apple", "B": "banana", "C": "orange"}
new_list = ["---" + key + "---" for key in data_dict]
print(new_list)

"""
もう一つサンプルです。キーと値の組み合わせの文字列を出力してみましょう。
"""

data_dict = {"A": "apple", "B": "banana", "C": "orange"}
new_list = [k + ":" + v for k, v in data_dict.items()]
print(new_list)    # ['A:apple', 'B:banana', 'C:orange']


"""
その他の内包表記

リスト以外に同様の記法でset、辞書を生成することが可能です。
リスト内包表記と比較すると出番が少ないかもしれませんが、ここで簡単に紹介したいと思います。

集合内包表記

リスト内包表記の大括弧を中括弧に変えるとsetの生成が可能です。
先程紹介したリスト内包表記と同様にsetを生成してみます。
"""

data_list = [5, 3, 7, 4, 10, 9, 6]
new_set = {num * 2 for num in data_list}
print(new_set)    # {6, 8, 10, 12, 14, 18, 20}


"""
辞書内包表記

リスト内包表記の大括弧を中括弧に変え、キーと値を指定すると新たな辞書を生成することが可能です。
以下のサンプルではリストの要素をキー、リストの要素を3倍したものを値とする新たな辞書を生成しています。
"""

data_list = [5, 3, 7, 4, 10, 9, 6]
new_dict = {num: num * 3 for num in data_list}
print(new_dict)    # {5: 15, 3: 9, 7: 21, 4: 12, 10: 30, 9: 27, 6: 18}

"""
最初は難しく感じるかもしれませんが、リスト等の生成が簡潔に記述でき、
処理も早くなるため是非マスターしてください。
"""


print("--- Python入門　while文---")


"""
while文

Pythonはループ処理のためにwhile文が用意されています。
while文はfor文と異なりループ中の条件式の結果に応じて続行するか否かを制御することができます。

while文の基本

以下の書き方となります。

while文
while 条件式:
    ループ内処理

まずは簡単なサンプルを紹介します。以下のコードではループ内で変数numに1ずつ加算しています。
変数numが10より小さい場合、ループ処理が継続され、10を超えるとループ処理が終了します。
"""

num = 0
while num < 10:
	num = num + 1
	print(num)

print('numの値:', num)

"""
最終的に、numの値が10になるまで加算されたことが確認できます。

もう1つサンプルで使い方を見てみましょう。
以下のサンプルは、endとキー入力するまでキー入力を要求し続けます。
（input関数はキー入力値を返す関数です）
"""

loop_flg = True    # ループ処理を継続するかどうかのフラグ

while loop_flg:
	print('キーを入力してくださいendで終了します')
	c = input()

	if c == 'end':
		loop_flg = False

	print(c + 'が入力されました。')


"""
break

for文と同様、breakを使用することができます。
ループを強制終了することができます。
以下のサンプルではループ中でendを入力した場合、breakが呼び出され即ループ処理を終了します。
なお、whileの後ろの条件式は常にTrueであるため、breakしない限りループし続けます。
"""

while True:
	print('キーを入力して下さいendを入力しない限りループし続けます')
	c = input()

	if c == 'end':
		break

	print(c + 'が入力されました。')


"""
while-else

for文と同様にwhile文に対してelseを使用することができます。for文と同様に、
breakしない場合はループ内の処理回数によらずelseブロック内部の処理は必ず実行されます。
以下のサンプルでは、endもしくはbreakと入力するまでループ処理が実行されます。
break以外の場合は必ずelse内部が実行されることが確認できます。
"""

loop_flg = True    # ループ処理を継続するかどうかのフラグ

while loop_flg:
	print('キーを入力してくださいendかbreakで処理を抜けられます')
	c = input()

	if c == 'end':
		# ループ処理のフラグをoffにする
		loop_flg = False
	elif c == 'break':
		# ループ処理をbreakで抜ける
		break

	print(c + 'が入力されました。')

else:
	print('処理を終了します')


"""
continue

こちらもfor文と同様、continueを使用するとその回の後続処理をスキップすることができます。
以下のサンプルではキー入力値をprint出力していますが、入力値がskipの場合、処理をスキップしています。
"""

loop_flg = True    # ループ処理を継続するかどうかのフラグ

while loop_flg:
	print('キーを入力してくださいendで終了します')
	c = input()

	if c == 'end':
		loop_flg = False
	elif c == 'skip':
		print('処理をスキップします')
		continue

	print(c + 'が入力されました。')


print("--- Python入門　pass ブロック内で何も処理を行わない場合---")


"""
制御文に関する学習の最後は制御ブロック内で何もしない場合の記述についてです。

ブロック内に記述が無いとエラーになる

Pythonで戸惑うことの１つにブロック内に記述が無いとエラーになる、ということが挙げられます。

例えばJavaの場合、以下のような記述が可能です。

if (x > 0){
    // x > 0の場合は処理を行わない
}

Pythonで同じようにブロック内の記述を省いた場合、IndentationErrorが発生します。

このような処理を行わないブロックの場合、Pythonでは明示的に処理を行わない、
ということがわかるようにpassを記述する必要があります。
"""

loop_flg = True    # ループ処理を継続するかどうかのフラグ

while loop_flg:
	print('数値を入力してください')
	x = input()

	if int(x) > 0:
		# x > 0の場合は処理を行わない
		pass
	elif x == 'end':
		loop_flg = False
	elif x == '0':
		print('終了します')
		break

	print(x + 'が入力されました。')
"""
今まで登場した制御文（if、else、for、whileなど）について、
ブロック内で何も処理を行わない場合はpassを記述するようにしてください。
"""


print("--- Python入門　関数の基本---")


"""
関数とは

ここまでPythonの様々な変数や制御文について学習してきました。
変数と制御文だけで比較的複雑な処理を作成できるようになるのですが、
処理が大きくなると様々な問題が出てきます。

    同じ処理を何回も書く必要がある
    処理の記述が散らばる

こういった問題は関数を使用することで解決することができます。
関数とは処理をひとつのブロックにまとめたもので、1回作れば何度も同じ処理を呼び出すことができます。
また、一連の処理をまとまって記述することができるため可読性を向上させることができます。
関数は引数と呼ばれる入力値に対して処理を行い、戻り値という値を呼び出し元に返すことができます。

基本的な関数の定義と呼び出し

それではPythonの関数を使ってみましょう。Pythonの関数の定義はdef文を使用します。

関数定義
def 関数名(引数):
    処理
    return 戻り値

def文の後ろに関数名を記述し、必要であれば引数を記述します。
def文の次の行からインデントをつけてブロック内に処理内容を記述します。
戻り値が必要である場合はreturnを記述します。
Pythonの引数の記法は様々あるので、次回以降詳しく解説します。

それでは実際に関数を作成してみましょう。以下のサンプルは2数の和を計算して返す関数です。
"""

def sample_function(x, y):
	z = x + y
	return z

"""
また、作った関数を呼び出す場合は以下のように記述します。
関数の呼び出し
戻り値を格納する変数 = 関数名(引数)

では、先程作成した関数を使ってみましょう。
以下のサンプルでは5行目で引数に1,2を指定してsample_functionを呼び出しています。
また、計算結果である戻り値を変数zに格納しています。
"""

def sample_fanction(x, y):
	z = x + y
	return z

z = sample_function(1, 2)
print(z)

"""
なお、returnのない関数は戻り値にNoneが設定されます。
以下の関数は戻り値がなく、Noneが返されzに格納されることが確認できます。
"""

def sample_function(x, y):
	print(x + y)

z = sample_function(1, 2)
print(z)    # None


"""
何もしない関数

テスト等で処理の記述がない関数を定義したい場合がありますが、
その場合は制御文で学習したpassを使用します。
"""

def sample_function(x, y):
	# 処理なし
	pass


"""
関数呼び出しの注意点

単一のスクリプトの場合、上から処理が実行されるため、
関数を呼び出す処理は、関数の後に記述してください。
例えば、以下のように関数の記述の前に呼び出し処理を実行すると、NameErrorが発生します。

z = sample_function(1, 2)
print(z)

def sample_function(x, y):
    z = x + y
    return z

実行すると、以下のエラーが発生します。

$ python sample.py
Traceback (most recent call last):
  File "sample.py", line 2, in <module>
    z = sample_function(1, 2)
NameError: name 'sample_function' is not defined

"""


print("--- Python入門　デフォルト引数---")


"""
デフォルト引数

Pythonの関数にはデフォルト引数と呼ばれる記法があります。
これを使用すると関数定義時に引数にデフォルト値を設定することが可能です。以下のように記述します。

関数定義
def 関数名(引数1=デフォルト値1, 引数2=デフォルト値2, ・・・):

それではサンプルです。以下のサンプルは2数の和を計算する関数です。
ただし、引数を指定しない場合はそれぞれ0が設定されます。
"""

# デフォルト引数の例
def sample_function(x=0, y=0):
	z = x + y
	return z


# パラメーターを指定して呼び出す
z1 = sample_function(5, 5)
print(z1)    # 10

# yを省略して呼び出す
z2 = sample_function(5)
print(z2)    # 5

# x, yを省略して呼び出す
z3 = sample_function()
print(z3)    # 0

"""
デフォルト引数の注意点として、デフォルト引数の後ろに通常の引数を設定することは不可という点です。
以下のコードはSyntaxErrorが発生し、実行することができません。

# デフォルト引数の後ろに通常の引数
def sample_function(x=0, y):
    z = x + y
    return z


sample_function(2, 3)
# SyntaxError: non-default argument follows default argument


デフォルト引数を使用する際の注意点

ここまでで関数定義で引数のデフォルト値を設定できることを説明しましたが、1点重要な注意点があります。
まずは以下のサンプルを見てください。
"""

def sample(x, arg=[]):
	arg.append(x)
	return arg

print(sample(1))    # [1]
print(sample(2))    # [1, 2]  !?
print(sample(3))    # [1, 2, 3]  !!??

"""
引数のリストに0を加えるsample関数を3回呼び出していますが、
2回め以降は設定されていないものが戻り値に加えられてしまっています。
これはデフォルト引数の評価は最初の1回しか行われないため、
appendのような破壊的な操作を行うと、デフォルト引数の値が1回めの呼び出しで[1]に、
2回めの呼び出しで[1, 2]に書き換わってしまうからです。
対策として、デフォルト引数にはイミュータブルなものを使用することで破壊されないようにし、
if文等で引数が空の場合の初期値設定の処理を加える、という方法があります。
"""

def sample(x, arg=None):
	if arg is None:
		arg = []

	arg.append(x)
	return arg

print(sample(1))    # [1]
print(sample(2))    # [2]
print(sample(3))    # [3]
