#!/usr/bin/python
# -*- coding: UTF-8 -*-


print("--- Python学習講座---")
print("--- Python入門　キーワード引数---")


"""
位置引数とキーワード引数

Pythonでは引数の指定方法が２つあります。
1つはこれまで解説したとおりオーソドックスに順番に指定する方法です。
このような指定方法を位置引数と呼びます。
2つ目は、キーワード引数と呼ばれ、引数名=値の形式で引数の順序に関係なく指定することができます。
サンプルで確認してみましょう。
"""

def sample_function(arg1, arg2):
	print(arg1, arg2)


sample_function('a', 'b')    # 順番に引数を指定する
sample_function(arg1='c', arg2='d')     # キーワードを指定する
sample_function(arg2='e', arg1='f')     # キーワードの場合は順番道理でなくてもよい
sample_function('c', arg2='d')    # 後方の引数のみキーワード指定

"""
関数を3回呼び出しています。
コード中のコメントで書いたとおり、キーワード引数の場合は順番どおりでなくても問題なく動くことが確認できます。
引数が多くなると引数への設定値を誤って書いてしまうことがありますが、
キーワード引数を使用するとこういった事故を防ぐことができます。

なお、キーワード引数の後ろに位置引数を設定することは許可されていません。
一方、後方の引数のみキーワード指定することは可能です。以下のサンプルはエラーが発生します。

def sample_function(arg1, arg2):
	print(arg1, arg2)

sample_function('c', arg2='d') # 後方の引数のみキーワード指定
sample_function(arg1='c', 'd') # キーワード引数の後ろに位置引数を指定
# SyntaxError: positional argument follows keyword argument


引数の展開

また、関数呼び出し時に複数の位置引数やキーワード引数を指定することが可能で、
関数側で自動的に引数が変数に展開されます。

位置引数をまとめて指定する
def 関数名(*リスト):

キーワード引数をまとめて指定する
def 関数名(**辞書):

以下のサンプルでは関数の呼び出し時に位置引数、キーワード引数をそれぞれまとめて指定しています。
"""

def sample_function(arg1, arg2):
	print(arg1, arg2)


# 位置引数をまとめて指定する例
arglist = ['a', 'b']
sample_function(*arglist)


# キーワード引数をまとめて指定する例
argdict = {'arg1': 'a', 'arg2': 'b'}
sample_function(**argdict)


print("--- Python入門　可変長引数---")


"""
可変長引数

可変長引数とは、関数の引数の数を呼び出し時に動的に変動させることができる記法です。
位置引数とキーワード引数とで分けて考えると理解がスムーズかと思います。

可変長な位置引数

可変長な位置引数を使用する場合は以下のように記述します。

可変長引数その1
def 関数名(引数1, 引数2,,,, *args):

サンプルです。以下は可変長な位置引数をもった関数です。
呼び出し側は引数の個数をいくつでも可変長に指定することができます。
一方、関数側はargsにタプルとして格納されます。
"""

def sample_function(x, y, *args):
	print(x, y, args)


sample_function('a', 'b')    # 引数２つ
# a b ()

sample_function('a', 'b', 'c')    # 位置引数１つ追加
# a b ('c',)

sample_function('a', 'b', 'c', 'd')     # 位置引数２つ追加
# a b ('c', 'd')

"""
実行すると、追加した引数がargsに格納されていることが確認できます。
なお、慣習上、可変長な位置引数はargsという名前がよく使用されます。

可変長なキーワード引数

可変長なキーワード引数を使用する場合は以下のように記述します。

可変長引数その2
def 関数名(引数1, 引数2,,,, **kwargs):

サンプルです。以下は可変長なキーワード引数をもった関数です。
呼び出し側はキーワード引数いくつでも可変長に指定することができます。
一方、関数側はkwargsに辞書形式で格納されます。
"""

def sample_function(x, y, **kwargs):
	print(x, y, kwargs)


sample_function('a', 'b')    # 引数２つ
# a b {}

sample_function('a', 'b', z='c')    # キーワード引数1つ追加
# a b {'z': 'c'}

sample_function('a', 'b', z='c', w='d')    # キーワード引数2つ追加
# a b {'z': 'c', 'w': 'd'}

"""
追加した引数がkwargsに格納されていることが確認できます。
なお、慣習上、可変長なキーワード引数はkwargsという名前がよく使用されます。

可変長な位置引数とキーワード引数

先程の可変長な位置引数、キーワード引数を合わせて記述することも可能です。

可変長引数その2
def 関数名(引数1, 引数2,,,, *args, **kwargs):
"""

def sample_function(x, y, *args, **kwargs):
	print(x, y, args, kwargs)


sample_function('a', 'b', 'c', w='d')    # 位置引数1つ追加 ＆ キーワード引数2つ追加
# a b ('c') {'w': 'd'}

"""
追加した位置引数がargsに、追加したキーワード引数がkwargsに格納されていることが確認できます。
"""


print("--- Python入門　global宣言---")

"""
ローカル変数とグローバル変数

これまで使用したPythonの変数の宣言箇所は大別すると以下の通り関数内外の2通りがあります。

    関数の外側
    関数の内側
"""

x = 100

def func():
	y = 'sample'
	print(y)

"""
上の例でいうとxは関数の外側、yは関数の内側で定義されています。
関数の外側で定義した変数をモジュール変数若しくはグローバル変数と呼びます。
（「グローバル変数」という名称には議論があるのですが、本稿では以降グローバル変数という用語を使用します。）
一方、関数の内側で定義した変数をローカル変数と呼びます。
ローカル変数は関数内部でのみ有効となります。
つまり、ある関数から別の関数のローカル変数は参照することができません。
一方で、グローバル変数は他の関数からも参照したり更新することが可能です。

グローバル変数の参照

関数の内部からグローバル変数の値を読み取る場合、特に何かをせず可能です。
以下のサンプルではグローバル変数xを関数sample_function内部で読み取っています。
"""

x = 100

def sample_function():
	print(x)    # 100が出力される

sample_function()

"""
実行すると変数xの値が出力されることが確認できます。
グローバル変数の更新

また、関数の内部でグローバル変数に代入した場合、ローカル変数の定義として扱われてしまいます。
この場合、グローバル変数は変更されません。
"""

x = 100

def sample_function():
	x = 200
	print(x)     # 200が出力される

sample_function()    # 関数内部でxの値を変更
print(x)    # 100が出力される。つまり、関数の外側の値は変更されない

"""
上のサンプルを実行すると、代入すると新たなローカル変数が生成され、
グローバル変数に代入できないことが確認できます。
では、グローバル変数を更新する場合はどうすればよいでしょうか？
これは、global宣言を記述することで解決します。
"""

x = 100

def sample_function():
	global x    # global宣言 xはglobal変数であることを明示する
	x = 200
	print(x)

sample_function()     # 関数内部でxの値を変更
print(x)    # 関数の外側の値が変更されている

"""
上のサンプルではグローバル変数が更新されていることが確認できます。
"""


print("--- Python入門　関数オブジェクト---")


"""
オブジェクトとしての関数

Pythonはこれまでに学習してきた様々な変数の型と同様、関数も変数に代入して扱うことができます。
以降、このように関数を変数として扱う場合の関数を当サイトでは関数オブジェクトと呼称することにします。
サンプルで見てみましょう。
"""

def sample_function():

	text = 'sample'
	print(text)
	return '戻り値'


text = sample_function()     # 通常の呼び出し
print(text)

f = sample_function    # 関数オブジェクトとして変数fに格納

text = f()     # 関数オブジェクトを実行
print(text)    # 戻り値も取得できる

"""
1行目から簡単な関数が定義されています。
8行目9行目では普通に関数を呼び出し、戻り値を取得して出力しています。
前述のとおり、関数をオブジェクトとして変数に格納することが可能で、11行目にそれを行っています。
13行目、14行目で実行、戻り値の出力を行っています。

関数宣言の引数として関数を渡すこともできます。もうひとつ例を見てみましょう。
"""

def param_func():
	return 'sample'

def sample_function(f):
	x = f()
	print(x)

sample_function(param_func)

"""
8行目でsample_function関数を実行していますが、引数としてparam_func関数を指定しています。
sample_function関数内部の5行目でparam_func関数が実行されて、6行目の出力でそれが確認できます。

関数を変数として扱うと、様々なトリックを使えるようになります。
最初は何の役に立つのか理解できないかもしれませんが、色んな場面で大活躍するので覚えておいてください。
"""


print("--- Python入門　内部関数（inner function）とnonlocal宣言---")


"""
内部関数（inner function）

Pythonでは、関数内部に関数を定義することが可能です。
この関数を内部関数（inner function）と呼びます。
"""

def outer_function():
	"""外側の関数"""
	print('outer')

	def inner_function():
		"""内側の関数"""
		print('inner')

	inner_function()

outer_function()

"""
先ほどの関数オブジェクトの考え方を応用すると、関数の戻り値として内部関数を返すことができます。
以下のサンプルでは、outer_functionを呼び出すと戻り値に
inner_functionを関数オブジェクトとして返しています。
"""

def outer_function():
	"""外側の関数"""
	print('outer')

	def inner_function():
		"""内側の関数"""
		print('inner')

	# 内側の関数をオブジェクトとしてreturnする
	f = inner_function
	return f

f = outer_function()
# 受け取った内側の関数を実行する
f()    # innerが出力される

"""
最初は違和感があるかもしれませんが、
「関数を実行すると戻り値に関数が得られる」
という実装は様々なライブラリを利用する際に見られるので知っておいてください。


nonlocal宣言

内側で定義した関数から外側のローカル関数を参照することが可能です。
内側の関数で外側のローカル変数を変更したい場合、nonlocal宣言を記述することでできるようになります。
global宣言と似ていますね。
"""

def outer_function():
	"""外側の関数"""

	x = 100
	print(x)    # 100が出力される

	def inner_function():
		"""内側の関数"""
		nonlocal x
		x = 200
		print(x)    # 200が出力される

	inner_function()
	print(x)    # 200が出力される


outer_function()

"""
外側の関数の変数が内部関数で変更されたことが確認できます。
"""


print("--- Python入門　ジェネレータ---")


"""
ジェネレータの基本
ジェネレータと__next__()メソッド

他のプログラム言語では聞き慣れない言葉だと思いますが、
Pythonの関数にはジェネレータという少し変わった実装をすることができます。
ジェネレータを利用すると、
関数の処理の途中で処理を一旦中断して値を返すことができ(これをyieldと呼びます)、
その後必要に応じて処理を再開することが可能となります。また、ループ処理で扱うことも可能です。

イメージがわきづらいかと思いますので、さっそくサンプルで確認してみましょう。
"""

def sample_generator():
	"""ジェネレータ関数"""
	yield 'おはよう'
	yield 'こんにちは'
	yield 'こんばんは'

gen_func = sample_generator()    # ジェネレータオブジェクトを生成する

text = gen_func.__next__()
print(text)    # おはよう

text = gen_func.__next__()
print(text)    # こんにちは

text = gen_func.__next__()
print(text)    # こんばんは

"""
コードの説明です。

サンプルのジェネレータ関数はyieldを3回持っています。
6行目でsample_generator関数を呼び出していますが、
関数から戻り値を受け取っているわけではなく、
イテラブル(=反復可能)なジェネレータオブジェクトを受け取っています。
9、12、15行目の__next__()メソッドでそれぞれのyieldまで実行されます。

ジェネレータはイテレータの一種なので、組込みのnext関数を利用したり、ループで処理することが可能です。
呼出し後の処理をループで書きなおしてみましょう。
"""

def sample_generator():
	yield 'おはよう'
	yield 'こんにちは'
	yield 'こんばんは'

gen_func = sample_generator()    # ジェネレータオブジェクトを生成する

for text in gen_func:
	print(text)


"""
ジェネレータと無限数列

この一風変わったジェネレータですが、利用するメリットはなんでしょうか？
例えば、何項目まで使うかわからない数列を予め生成して、1つづつ取り出す処理ついて考えてみます。
現実的に使う程度のサイズを見積もって大きなリストを作る方法が考えられますが、
見積もりが悪ければ不足してしまいすし、ほとんど使わないデータを確保し続けるためメモリがもったいないですね。
そんなときはジェネレータを使いましょう。

以下、フィボナッチ数列をyieldで返すジェネレータ関数のサンプルです。
(フィボナッチ数列とは初項f0=1とその次の項f1=1が与えられていた場合、
fn=fn + fn-1で定義される数列です。)
"""

def fibonacci_generator():
	f0, f1 = 0, 1
	while True:
		yield f0
		f0, f1 = f1, f0 + f1

gen_func = fibonacci_generator()    # ジェネレータオブジェクトを生成する

for i in range(0, 10):
	# 10個取得する
	num = next(gen_func)
	print(num)

"""
この実装ならば、巨大なリストを予め作らなくても、必要なときに次の項を取得することができます。
ディレクトリツリーやカテゴリツリーといった最木構造を持ったデータを表形式に変換する際にも活用することができます。


ジェネレータのメソッド

ジェネレータのメソッドは、さきほど紹介した__next__()メソッド以外に、
send()メソッド、throw()メソッド、close()メソッドがあります。

順番に説明していきましょう。
send()メソッド

再開待ちのジェネレータに対し、値を設定します。
sendメソッドで指定した値はyield式の値として設定されます。
"""

def sample_generator():
	text = yield 'おはよう'
	yield text
	yield text

gen_func = sample_generator()    # ジェネレータオブジェクトを生成する

text = next(gen_func)
print(text)

text = gen_func.send('こんにちは')
print(text)

text = next(gen_func)
print(text)

"""
8行目でジェネレータオブジェクトから値を取得します。

11行目で値を送出し値を設定し、3行目のyieldで返された値を出力します。

14行目のnextでは4行目のyieldで返された値を出力します。


throw()メソッド

再開待ちのジェネレータオブジェクトに対し、例外を送出します。


close()メソッド

再開待ちのジェネレータオブジェクトを正常終了させます。
"""
